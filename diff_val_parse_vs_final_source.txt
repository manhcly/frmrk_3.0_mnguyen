diff -r xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/arch/arm64/configs/xgene_defconfig /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/arch/arm64/configs/xgene_defconfig
3c3
< # Linux/arm64 4.5.0-27.el7.170727+apm.ilp32.aarch64 Kernel Configuration
---
> # Linux/arm64 4.5.0-27.el7.170817+apm.ilp32.aarch64 Kernel Configuration
1015c1015,1016
< # CONFIG_MTD_BLOCK is not set
---
> CONFIG_MTD_BLKDEVS=m
> CONFIG_MTD_BLOCK=m
1030c1031
< # CONFIG_MTD_CFI is not set
---
> CONFIG_MTD_CFI=y
1044,1046c1045,1047
< # CONFIG_MTD_CFI_INTELEXT is not set
< # CONFIG_MTD_CFI_AMDSTD is not set
< # CONFIG_MTD_CFI_STAA is not set
---
> CONFIG_MTD_CFI_INTELEXT=y
> CONFIG_MTD_CFI_AMDSTD=y
> CONFIG_MTD_CFI_STAA=y
1055a1057
> CONFIG_MTD_PHYSMAP=y
Only in xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/arch/sh/boot/compressed: vmlinux.scr
Only in xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/arch/sh/boot/romimage: vmlinux.scr
Only in /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/certs: signing_key.pem
Only in /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/certs: signing_key.x509
Only in /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/certs: x509.genkey
Only in xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/Documentation/DocBook/media/dvb: dvbstb.pdf
Only in xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/Documentation/DocBook/media/v4l: crop.pdf
Only in xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/Documentation/DocBook/media/v4l: fieldseq_bt.pdf
Only in xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/Documentation/DocBook/media/v4l: fieldseq_tb.pdf
Only in xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/Documentation/DocBook/media/v4l: pipeline.pdf
Only in xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/Documentation/DocBook/media/v4l: vbi_525.pdf
Only in xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/Documentation/DocBook/media/v4l: vbi_625.pdf
Only in xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/Documentation/DocBook/media/v4l: vbi_hsync.pdf
diff -r xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/drivers/Makefile /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/drivers/Makefile
176c176
< obj-$(CONFIG_HELLO_DRIVER_Device)	+= hello/
---
> obj-$(CONFIG_HELLO_DRIVER_Device)	+= hello/
\ No newline at end of file
diff -r xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/drivers/usb/host/xhci.c /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/drivers/usb/host/xhci.c
4179,4180c4179,5093
< //	if (enable) {
< 	if (0) {
---
> 	if (enable && !(xhci->quirks & XHCI_HW_LPM_DISABLE)) {
> 		/* Host supports BESL timeout instead of HIRD */
> 		if (udev->usb2_hw_lpm_besl_capable) {
> 			/* if device doesn't have a preferred BESL value use a
> 			 * default one which works with mixed HIRD and BESL
> 			 * systems. See XHCI_DEFAULT_BESL definition in xhci.h
> 			 */
> 			if ((field & USB_BESL_SUPPORT) &&
> 			    (field & USB_BESL_BASELINE_VALID))
> 				hird = USB_GET_BESL_BASELINE(field);
> 			else
> 				hird = udev->l1_params.besl;
> 
> 			exit_latency = xhci_besl_encoding[hird];
> 			spin_unlock_irqrestore(&xhci->lock, flags);
> 
> 			/* USB 3.0 code dedicate one xhci->lpm_command->in_ctx
> 			 * input context for link powermanagement evaluate
> 			 * context commands. It is protected by hcd->bandwidth
> 			 * mutex and is shared by all devices. We need to set
> 			 * the max ext latency in USB 2 BESL LPM as well, so
> 			 * use the same mutex and xhci_change_max_exit_latency()
> 			 */
> 			mutex_lock(hcd->bandwidth_mutex);
> 			ret = xhci_change_max_exit_latency(xhci, udev,
> 							   exit_latency);
> 			mutex_unlock(hcd->bandwidth_mutex);
> 
> 			if (ret < 0)
> 				return ret;
> 			spin_lock_irqsave(&xhci->lock, flags);
> 
> 			hlpm_val = xhci_calculate_usb2_hw_lpm_params(udev);
> 			writel(hlpm_val, hlpm_addr);
> 			/* flush write */
> 			readl(hlpm_addr);
> 		} else {
> 			hird = xhci_calculate_hird_besl(xhci, udev);
> 		}
> 
> 		pm_val &= ~PORT_HIRD_MASK;
> 		pm_val |= PORT_HIRD(hird) | PORT_RWE | PORT_L1DS(udev->slot_id);
> 		writel(pm_val, pm_addr);
> 		pm_val = readl(pm_addr);
> 		pm_val |= PORT_HLE;
> 		writel(pm_val, pm_addr);
> 		/* flush write */
> 		readl(pm_addr);
> 	} else {
> 		pm_val &= ~(PORT_HLE | PORT_RWE | PORT_HIRD_MASK | PORT_L1DS_MASK);
> 		writel(pm_val, pm_addr);
> 		/* flush write */
> 		readl(pm_addr);
> 		if (udev->usb2_hw_lpm_besl_capable) {
> 			spin_unlock_irqrestore(&xhci->lock, flags);
> 			mutex_lock(hcd->bandwidth_mutex);
> 			xhci_change_max_exit_latency(xhci, udev, 0);
> 			mutex_unlock(hcd->bandwidth_mutex);
> 			return 0;
> 		}
> 	}
> 
> 	spin_unlock_irqrestore(&xhci->lock, flags);
> 	return 0;
> }
> 
> /* check if a usb2 port supports a given extened capability protocol
>  * only USB2 ports extended protocol capability values are cached.
>  * Return 1 if capability is supported
>  */
> static int xhci_check_usb2_port_capability(struct xhci_hcd *xhci, int port,
> 					   unsigned capability)
> {
> 	u32 port_offset, port_count;
> 	int i;
> 
> 	for (i = 0; i < xhci->num_ext_caps; i++) {
> 		if (xhci->ext_caps[i] & capability) {
> 			/* port offsets starts at 1 */
> 			port_offset = XHCI_EXT_PORT_OFF(xhci->ext_caps[i]) - 1;
> 			port_count = XHCI_EXT_PORT_COUNT(xhci->ext_caps[i]);
> 			if (port >= port_offset &&
> 			    port < port_offset + port_count)
> 				return 1;
> 		}
> 	}
> 	return 0;
> }
> 
> int xhci_update_device(struct usb_hcd *hcd, struct usb_device *udev)
> {
> 	struct xhci_hcd	*xhci = hcd_to_xhci(hcd);
> 	int		portnum = udev->portnum - 1;
> 
> 	if (hcd->speed >= HCD_USB3 || !xhci->sw_lpm_support ||
> 			!udev->lpm_capable)
> 		return 0;
> 
> 	/* we only support lpm for non-hub device connected to root hub yet */
> 	if (!udev->parent || udev->parent->parent ||
> 			udev->descriptor.bDeviceClass == USB_CLASS_HUB)
> 		return 0;
> 
> 	if (xhci->hw_lpm_support == 1 &&
> 			xhci_check_usb2_port_capability(
> 				xhci, portnum, XHCI_HLC)) {
> 		udev->usb2_hw_lpm_capable = 1;
> 		udev->l1_params.timeout = XHCI_L1_TIMEOUT;
> 		udev->l1_params.besl = XHCI_DEFAULT_BESL;
> 		if (xhci_check_usb2_port_capability(xhci, portnum,
> 					XHCI_BLC))
> 			udev->usb2_hw_lpm_besl_capable = 1;
> 	}
> 
> 	return 0;
> }
> 
> /*---------------------- USB 3.0 Link PM functions ------------------------*/
> 
> /* Service interval in nanoseconds = 2^(bInterval - 1) * 125us * 1000ns / 1us */
> static unsigned long long xhci_service_interval_to_ns(
> 		struct usb_endpoint_descriptor *desc)
> {
> 	return (1ULL << (desc->bInterval - 1)) * 125 * 1000;
> }
> 
> static u16 xhci_get_timeout_no_hub_lpm(struct usb_device *udev,
> 		enum usb3_link_state state)
> {
> 	unsigned long long sel;
> 	unsigned long long pel;
> 	unsigned int max_sel_pel;
> 	char *state_name;
> 
> 	switch (state) {
> 	case USB3_LPM_U1:
> 		/* Convert SEL and PEL stored in nanoseconds to microseconds */
> 		sel = DIV_ROUND_UP(udev->u1_params.sel, 1000);
> 		pel = DIV_ROUND_UP(udev->u1_params.pel, 1000);
> 		max_sel_pel = USB3_LPM_MAX_U1_SEL_PEL;
> 		state_name = "U1";
> 		break;
> 	case USB3_LPM_U2:
> 		sel = DIV_ROUND_UP(udev->u2_params.sel, 1000);
> 		pel = DIV_ROUND_UP(udev->u2_params.pel, 1000);
> 		max_sel_pel = USB3_LPM_MAX_U2_SEL_PEL;
> 		state_name = "U2";
> 		break;
> 	default:
> 		dev_warn(&udev->dev, "%s: Can't get timeout for non-U1 or U2 state.\n",
> 				__func__);
> 		return USB3_LPM_DISABLED;
> 	}
> 
> 	if (sel <= max_sel_pel && pel <= max_sel_pel)
> 		return USB3_LPM_DEVICE_INITIATED;
> 
> 	if (sel > max_sel_pel)
> 		dev_dbg(&udev->dev, "Device-initiated %s disabled "
> 				"due to long SEL %llu ms\n",
> 				state_name, sel);
> 	else
> 		dev_dbg(&udev->dev, "Device-initiated %s disabled "
> 				"due to long PEL %llu ms\n",
> 				state_name, pel);
> 	return USB3_LPM_DISABLED;
> }
> 
> /* The U1 timeout should be the maximum of the following values:
>  *  - For control endpoints, U1 system exit latency (SEL) * 3
>  *  - For bulk endpoints, U1 SEL * 5
>  *  - For interrupt endpoints:
>  *    - Notification EPs, U1 SEL * 3
>  *    - Periodic EPs, max(105% of bInterval, U1 SEL * 2)
>  *  - For isochronous endpoints, max(105% of bInterval, U1 SEL * 2)
>  */
> static unsigned long long xhci_calculate_intel_u1_timeout(
> 		struct usb_device *udev,
> 		struct usb_endpoint_descriptor *desc)
> {
> 	unsigned long long timeout_ns;
> 	int ep_type;
> 	int intr_type;
> 
> 	ep_type = usb_endpoint_type(desc);
> 	switch (ep_type) {
> 	case USB_ENDPOINT_XFER_CONTROL:
> 		timeout_ns = udev->u1_params.sel * 3;
> 		break;
> 	case USB_ENDPOINT_XFER_BULK:
> 		timeout_ns = udev->u1_params.sel * 5;
> 		break;
> 	case USB_ENDPOINT_XFER_INT:
> 		intr_type = usb_endpoint_interrupt_type(desc);
> 		if (intr_type == USB_ENDPOINT_INTR_NOTIFICATION) {
> 			timeout_ns = udev->u1_params.sel * 3;
> 			break;
> 		}
> 		/* Otherwise the calculation is the same as isoc eps */
> 	case USB_ENDPOINT_XFER_ISOC:
> 		timeout_ns = xhci_service_interval_to_ns(desc);
> 		timeout_ns = DIV_ROUND_UP_ULL(timeout_ns * 105, 100);
> 		if (timeout_ns < udev->u1_params.sel * 2)
> 			timeout_ns = udev->u1_params.sel * 2;
> 		break;
> 	default:
> 		return 0;
> 	}
> 
> 	return timeout_ns;
> }
> 
> /* Returns the hub-encoded U1 timeout value. */
> static u16 xhci_calculate_u1_timeout(struct xhci_hcd *xhci,
> 		struct usb_device *udev,
> 		struct usb_endpoint_descriptor *desc)
> {
> 	unsigned long long timeout_ns;
> 
> 	if (xhci->quirks & XHCI_INTEL_HOST)
> 		timeout_ns = xhci_calculate_intel_u1_timeout(udev, desc);
> 	else
> 		timeout_ns = udev->u1_params.sel;
> 
> 	/* The U1 timeout is encoded in 1us intervals.
> 	 * Don't return a timeout of zero, because that's USB3_LPM_DISABLED.
> 	 */
> 	if (timeout_ns == USB3_LPM_DISABLED)
> 		timeout_ns = 1;
> 	else
> 		timeout_ns = DIV_ROUND_UP_ULL(timeout_ns, 1000);
> 
> 	/* If the necessary timeout value is bigger than what we can set in the
> 	 * USB 3.0 hub, we have to disable hub-initiated U1.
> 	 */
> 	if (timeout_ns <= USB3_LPM_U1_MAX_TIMEOUT)
> 		return timeout_ns;
> 	dev_dbg(&udev->dev, "Hub-initiated U1 disabled "
> 			"due to long timeout %llu ms\n", timeout_ns);
> 	return xhci_get_timeout_no_hub_lpm(udev, USB3_LPM_U1);
> }
> 
> /* The U2 timeout should be the maximum of:
>  *  - 10 ms (to avoid the bandwidth impact on the scheduler)
>  *  - largest bInterval of any active periodic endpoint (to avoid going
>  *    into lower power link states between intervals).
>  *  - the U2 Exit Latency of the device
>  */
> static unsigned long long xhci_calculate_intel_u2_timeout(
> 		struct usb_device *udev,
> 		struct usb_endpoint_descriptor *desc)
> {
> 	unsigned long long timeout_ns;
> 	unsigned long long u2_del_ns;
> 
> 	timeout_ns = 10 * 1000 * 1000;
> 
> 	if ((usb_endpoint_xfer_int(desc) || usb_endpoint_xfer_isoc(desc)) &&
> 			(xhci_service_interval_to_ns(desc) > timeout_ns))
> 		timeout_ns = xhci_service_interval_to_ns(desc);
> 
> 	u2_del_ns = le16_to_cpu(udev->bos->ss_cap->bU2DevExitLat) * 1000ULL;
> 	if (u2_del_ns > timeout_ns)
> 		timeout_ns = u2_del_ns;
> 
> 	return timeout_ns;
> }
> 
> /* Returns the hub-encoded U2 timeout value. */
> static u16 xhci_calculate_u2_timeout(struct xhci_hcd *xhci,
> 		struct usb_device *udev,
> 		struct usb_endpoint_descriptor *desc)
> {
> 	unsigned long long timeout_ns;
> 
> 	if (xhci->quirks & XHCI_INTEL_HOST)
> 		timeout_ns = xhci_calculate_intel_u2_timeout(udev, desc);
> 	else
> 		timeout_ns = udev->u2_params.sel;
> 
> 	/* The U2 timeout is encoded in 256us intervals */
> 	timeout_ns = DIV_ROUND_UP_ULL(timeout_ns, 256 * 1000);
> 	/* If the necessary timeout value is bigger than what we can set in the
> 	 * USB 3.0 hub, we have to disable hub-initiated U2.
> 	 */
> 	if (timeout_ns <= USB3_LPM_U2_MAX_TIMEOUT)
> 		return timeout_ns;
> 	dev_dbg(&udev->dev, "Hub-initiated U2 disabled "
> 			"due to long timeout %llu ms\n", timeout_ns);
> 	return xhci_get_timeout_no_hub_lpm(udev, USB3_LPM_U2);
> }
> 
> static u16 xhci_call_host_update_timeout_for_endpoint(struct xhci_hcd *xhci,
> 		struct usb_device *udev,
> 		struct usb_endpoint_descriptor *desc,
> 		enum usb3_link_state state,
> 		u16 *timeout)
> {
> 	if (state == USB3_LPM_U1)
> 		return xhci_calculate_u1_timeout(xhci, udev, desc);
> 	else if (state == USB3_LPM_U2)
> 		return xhci_calculate_u2_timeout(xhci, udev, desc);
> 
> 	return USB3_LPM_DISABLED;
> }
> 
> static int xhci_update_timeout_for_endpoint(struct xhci_hcd *xhci,
> 		struct usb_device *udev,
> 		struct usb_endpoint_descriptor *desc,
> 		enum usb3_link_state state,
> 		u16 *timeout)
> {
> 	u16 alt_timeout;
> 
> 	alt_timeout = xhci_call_host_update_timeout_for_endpoint(xhci, udev,
> 		desc, state, timeout);
> 
> 	/* If we found we can't enable hub-initiated LPM, or
> 	 * the U1 or U2 exit latency was too high to allow
> 	 * device-initiated LPM as well, just stop searching.
> 	 */
> 	if (alt_timeout == USB3_LPM_DISABLED ||
> 			alt_timeout == USB3_LPM_DEVICE_INITIATED) {
> 		*timeout = alt_timeout;
> 		return -E2BIG;
> 	}
> 	if (alt_timeout > *timeout)
> 		*timeout = alt_timeout;
> 	return 0;
> }
> 
> static int xhci_update_timeout_for_interface(struct xhci_hcd *xhci,
> 		struct usb_device *udev,
> 		struct usb_host_interface *alt,
> 		enum usb3_link_state state,
> 		u16 *timeout)
> {
> 	int j;
> 
> 	for (j = 0; j < alt->desc.bNumEndpoints; j++) {
> 		if (xhci_update_timeout_for_endpoint(xhci, udev,
> 					&alt->endpoint[j].desc, state, timeout))
> 			return -E2BIG;
> 		continue;
> 	}
> 	return 0;
> }
> 
> static int xhci_check_intel_tier_policy(struct usb_device *udev,
> 		enum usb3_link_state state)
> {
> 	struct usb_device *parent;
> 	unsigned int num_hubs;
> 
> 	if (state == USB3_LPM_U2)
> 		return 0;
> 
> 	/* Don't enable U1 if the device is on a 2nd tier hub or lower. */
> 	for (parent = udev->parent, num_hubs = 0; parent->parent;
> 			parent = parent->parent)
> 		num_hubs++;
> 
> 	if (num_hubs < 2)
> 		return 0;
> 
> 	dev_dbg(&udev->dev, "Disabling U1 link state for device"
> 			" below second-tier hub.\n");
> 	dev_dbg(&udev->dev, "Plug device into first-tier hub "
> 			"to decrease power consumption.\n");
> 	return -E2BIG;
> }
> 
> static int xhci_check_tier_policy(struct xhci_hcd *xhci,
> 		struct usb_device *udev,
> 		enum usb3_link_state state)
> {
> 	if (xhci->quirks & XHCI_INTEL_HOST)
> 		return xhci_check_intel_tier_policy(udev, state);
> 	else
> 		return 0;
> }
> 
> /* Returns the U1 or U2 timeout that should be enabled.
>  * If the tier check or timeout setting functions return with a non-zero exit
>  * code, that means the timeout value has been finalized and we shouldn't look
>  * at any more endpoints.
>  */
> static u16 xhci_calculate_lpm_timeout(struct usb_hcd *hcd,
> 			struct usb_device *udev, enum usb3_link_state state)
> {
> 	struct xhci_hcd *xhci = hcd_to_xhci(hcd);
> 	struct usb_host_config *config;
> 	char *state_name;
> 	int i;
> 	u16 timeout = USB3_LPM_DISABLED;
> 
> 	if (state == USB3_LPM_U1)
> 		state_name = "U1";
> 	else if (state == USB3_LPM_U2)
> 		state_name = "U2";
> 	else {
> 		dev_warn(&udev->dev, "Can't enable unknown link state %i\n",
> 				state);
> 		return timeout;
> 	}
> 
> 	if (xhci_check_tier_policy(xhci, udev, state) < 0)
> 		return timeout;
> 
> 	/* Gather some information about the currently installed configuration
> 	 * and alternate interface settings.
> 	 */
> 	if (xhci_update_timeout_for_endpoint(xhci, udev, &udev->ep0.desc,
> 			state, &timeout))
> 		return timeout;
> 
> 	config = udev->actconfig;
> 	if (!config)
> 		return timeout;
> 
> 	for (i = 0; i < config->desc.bNumInterfaces; i++) {
> 		struct usb_driver *driver;
> 		struct usb_interface *intf = config->interface[i];
> 
> 		if (!intf)
> 			continue;
> 
> 		/* Check if any currently bound drivers want hub-initiated LPM
> 		 * disabled.
> 		 */
> 		if (intf->dev.driver) {
> 			driver = to_usb_driver(intf->dev.driver);
> 			if (driver && driver->disable_hub_initiated_lpm) {
> 				dev_dbg(&udev->dev, "Hub-initiated %s disabled "
> 						"at request of driver %s\n",
> 						state_name, driver->name);
> 				return xhci_get_timeout_no_hub_lpm(udev, state);
> 			}
> 		}
> 
> 		/* Not sure how this could happen... */
> 		if (!intf->cur_altsetting)
> 			continue;
> 
> 		if (xhci_update_timeout_for_interface(xhci, udev,
> 					intf->cur_altsetting,
> 					state, &timeout))
> 			return timeout;
> 	}
> 	return timeout;
> }
> 
> static int calculate_max_exit_latency(struct usb_device *udev,
> 		enum usb3_link_state state_changed,
> 		u16 hub_encoded_timeout)
> {
> 	unsigned long long u1_mel_us = 0;
> 	unsigned long long u2_mel_us = 0;
> 	unsigned long long mel_us = 0;
> 	bool disabling_u1;
> 	bool disabling_u2;
> 	bool enabling_u1;
> 	bool enabling_u2;
> 
> 	disabling_u1 = (state_changed == USB3_LPM_U1 &&
> 			hub_encoded_timeout == USB3_LPM_DISABLED);
> 	disabling_u2 = (state_changed == USB3_LPM_U2 &&
> 			hub_encoded_timeout == USB3_LPM_DISABLED);
> 
> 	enabling_u1 = (state_changed == USB3_LPM_U1 &&
> 			hub_encoded_timeout != USB3_LPM_DISABLED);
> 	enabling_u2 = (state_changed == USB3_LPM_U2 &&
> 			hub_encoded_timeout != USB3_LPM_DISABLED);
> 
> 	/* If U1 was already enabled and we're not disabling it,
> 	 * or we're going to enable U1, account for the U1 max exit latency.
> 	 */
> 	if ((udev->u1_params.timeout != USB3_LPM_DISABLED && !disabling_u1) ||
> 			enabling_u1)
> 		u1_mel_us = DIV_ROUND_UP(udev->u1_params.mel, 1000);
> 	if ((udev->u2_params.timeout != USB3_LPM_DISABLED && !disabling_u2) ||
> 			enabling_u2)
> 		u2_mel_us = DIV_ROUND_UP(udev->u2_params.mel, 1000);
> 
> 	if (u1_mel_us > u2_mel_us)
> 		mel_us = u1_mel_us;
> 	else
> 		mel_us = u2_mel_us;
> 	/* xHCI host controller max exit latency field is only 16 bits wide. */
> 	if (mel_us > MAX_EXIT) {
> 		dev_warn(&udev->dev, "Link PM max exit latency of %lluus "
> 				"is too big.\n", mel_us);
> 		return -E2BIG;
> 	}
> 	return mel_us;
> }
> 
> /* Returns the USB3 hub-encoded value for the U1/U2 timeout. */
> int xhci_enable_usb3_lpm_timeout(struct usb_hcd *hcd,
> 			struct usb_device *udev, enum usb3_link_state state)
> {
> 	struct xhci_hcd	*xhci;
> 	u16 hub_encoded_timeout;
> 	int mel;
> 	int ret;
> 
> 	xhci = hcd_to_xhci(hcd);
> 	/* The LPM timeout values are pretty host-controller specific, so don't
> 	 * enable hub-initiated timeouts unless the vendor has provided
> 	 * information about their timeout algorithm.
> 	 */
> 	if (!xhci || !(xhci->quirks & XHCI_LPM_SUPPORT) ||
> 			!xhci->devs[udev->slot_id])
> 		return USB3_LPM_DISABLED;
> 
> 	hub_encoded_timeout = xhci_calculate_lpm_timeout(hcd, udev, state);
> 	mel = calculate_max_exit_latency(udev, state, hub_encoded_timeout);
> 	if (mel < 0) {
> 		/* Max Exit Latency is too big, disable LPM. */
> 		hub_encoded_timeout = USB3_LPM_DISABLED;
> 		mel = 0;
> 	}
> 
> 	ret = xhci_change_max_exit_latency(xhci, udev, mel);
> 	if (ret)
> 		return ret;
> 	return hub_encoded_timeout;
> }
> 
> int xhci_disable_usb3_lpm_timeout(struct usb_hcd *hcd,
> 			struct usb_device *udev, enum usb3_link_state state)
> {
> 	struct xhci_hcd	*xhci;
> 	u16 mel;
> 
> 	xhci = hcd_to_xhci(hcd);
> 	if (!xhci || !(xhci->quirks & XHCI_LPM_SUPPORT) ||
> 			!xhci->devs[udev->slot_id])
> 		return 0;
> 
> 	mel = calculate_max_exit_latency(udev, state, USB3_LPM_DISABLED);
> 	return xhci_change_max_exit_latency(xhci, udev, mel);
> }
> #else /* CONFIG_PM */
> 
> int xhci_set_usb2_hardware_lpm(struct usb_hcd *hcd,
> 				struct usb_device *udev, int enable)
> {
> 	return 0;
> }
> 
> int xhci_update_device(struct usb_hcd *hcd, struct usb_device *udev)
> {
> 	return 0;
> }
> 
> int xhci_enable_usb3_lpm_timeout(struct usb_hcd *hcd,
> 			struct usb_device *udev, enum usb3_link_state state)
> {
> 	return USB3_LPM_DISABLED;
> }
> 
> int xhci_disable_usb3_lpm_timeout(struct usb_hcd *hcd,
> 			struct usb_device *udev, enum usb3_link_state state)
> {
> 	return 0;
> }
> #endif	/* CONFIG_PM */
> 
> /*-------------------------------------------------------------------------*/
> 
> /* Once a hub descriptor is fetched for a device, we need to update the xHC's
>  * internal data structures for the device.
>  */
> int xhci_update_hub_device(struct usb_hcd *hcd, struct usb_device *hdev,
> 			struct usb_tt *tt, gfp_t mem_flags)
> {
> 	struct xhci_hcd *xhci = hcd_to_xhci(hcd);
> 	struct xhci_virt_device *vdev;
> 	struct xhci_command *config_cmd;
> 	struct xhci_input_control_ctx *ctrl_ctx;
> 	struct xhci_slot_ctx *slot_ctx;
> 	unsigned long flags;
> 	unsigned think_time;
> 	int ret;
> 
> 	/* Ignore root hubs */
> 	if (!hdev->parent)
> 		return 0;
> 
> 	vdev = xhci->devs[hdev->slot_id];
> 	if (!vdev) {
> 		xhci_warn(xhci, "Cannot update hub desc for unknown device.\n");
> 		return -EINVAL;
> 	}
> 	config_cmd = xhci_alloc_command(xhci, true, true, mem_flags);
> 	if (!config_cmd) {
> 		xhci_dbg(xhci, "Could not allocate xHCI command structure.\n");
> 		return -ENOMEM;
> 	}
> 	ctrl_ctx = xhci_get_input_control_ctx(config_cmd->in_ctx);
> 	if (!ctrl_ctx) {
> 		xhci_warn(xhci, "%s: Could not get input context, bad type.\n",
> 				__func__);
> 		xhci_free_command(xhci, config_cmd);
> 		return -ENOMEM;
> 	}
> 
> 	spin_lock_irqsave(&xhci->lock, flags);
> 	if (hdev->speed == USB_SPEED_HIGH &&
> 			xhci_alloc_tt_info(xhci, vdev, hdev, tt, GFP_ATOMIC)) {
> 		xhci_dbg(xhci, "Could not allocate xHCI TT structure.\n");
> 		xhci_free_command(xhci, config_cmd);
> 		spin_unlock_irqrestore(&xhci->lock, flags);
> 		return -ENOMEM;
> 	}
> 
> 	xhci_slot_copy(xhci, config_cmd->in_ctx, vdev->out_ctx);
> 	ctrl_ctx->add_flags |= cpu_to_le32(SLOT_FLAG);
> 	slot_ctx = xhci_get_slot_ctx(xhci, config_cmd->in_ctx);
> 	slot_ctx->dev_info |= cpu_to_le32(DEV_HUB);
> 	/*
> 	 * refer to section 6.2.2: MTT should be 0 for full speed hub,
> 	 * but it may be already set to 1 when setup an xHCI virtual
> 	 * device, so clear it anyway.
> 	 */
> 	if (tt->multi)
> 		slot_ctx->dev_info |= cpu_to_le32(DEV_MTT);
> 	else if (hdev->speed == USB_SPEED_FULL)
> 		slot_ctx->dev_info &= cpu_to_le32(~DEV_MTT);
> 
> 	if (xhci->hci_version > 0x95) {
> 		xhci_dbg(xhci, "xHCI version %x needs hub "
> 				"TT think time and number of ports\n",
> 				(unsigned int) xhci->hci_version);
> 		slot_ctx->dev_info2 |= cpu_to_le32(XHCI_MAX_PORTS(hdev->maxchild));
> 		/* Set TT think time - convert from ns to FS bit times.
> 		 * 0 = 8 FS bit times, 1 = 16 FS bit times,
> 		 * 2 = 24 FS bit times, 3 = 32 FS bit times.
> 		 *
> 		 * xHCI 1.0: this field shall be 0 if the device is not a
> 		 * High-spped hub.
> 		 */
> 		think_time = tt->think_time;
> 		if (think_time != 0)
> 			think_time = (think_time / 666) - 1;
> 		if (xhci->hci_version < 0x100 || hdev->speed == USB_SPEED_HIGH)
> 			slot_ctx->tt_info |=
> 				cpu_to_le32(TT_THINK_TIME(think_time));
> 	} else {
> 		xhci_dbg(xhci, "xHCI version %x doesn't need hub "
> 				"TT think time or number of ports\n",
> 				(unsigned int) xhci->hci_version);
> 	}
> 	slot_ctx->dev_state = 0;
> 	spin_unlock_irqrestore(&xhci->lock, flags);
> 
> 	xhci_dbg(xhci, "Set up %s for hub device.\n",
> 			(xhci->hci_version > 0x95) ?
> 			"configure endpoint" : "evaluate context");
> 	xhci_dbg(xhci, "Slot %u Input Context:\n", hdev->slot_id);
> 	xhci_dbg_ctx(xhci, config_cmd->in_ctx, 0);
> 
> 	/* Issue and wait for the configure endpoint or
> 	 * evaluate context command.
> 	 */
> 	if (xhci->hci_version > 0x95)
> 		ret = xhci_configure_endpoint(xhci, hdev, config_cmd,
> 				false, false);
> 	else
> 		ret = xhci_configure_endpoint(xhci, hdev, config_cmd,
> 				true, false);
> 
> 	xhci_dbg(xhci, "Slot %u Output Context:\n", hdev->slot_id);
> 	xhci_dbg_ctx(xhci, vdev->out_ctx, 0);
> 
> 	xhci_free_command(xhci, config_cmd);
> 	return ret;
> }
> 
> int xhci_get_frame(struct usb_hcd *hcd)
> {
> 	struct xhci_hcd *xhci = hcd_to_xhci(hcd);
> 	/* EHCI mods by the periodic size.  Why? */
> 	return readl(&xhci->run_regs->microframe_index) >> 3;
> }
> 
> int xhci_gen_setup(struct usb_hcd *hcd, xhci_get_quirks_t get_quirks)
> {
> 	struct xhci_hcd		*xhci;
> 	struct device		*dev = hcd->self.controller;
> 	int			retval;
> 
> 	/* Accept arbitrarily long scatter-gather lists */
> 	hcd->self.sg_tablesize = ~0;
> 
> 	/* support to build packet from discontinuous buffers */
> 	hcd->self.no_sg_constraint = 1;
> 
> 	/* XHCI controllers don't stop the ep queue on short packets :| */
> 	hcd->self.no_stop_on_short = 1;
> 
> 	xhci = hcd_to_xhci(hcd);
> 
> 	if (usb_hcd_is_primary_hcd(hcd)) {
> 		xhci->main_hcd = hcd;
> 		/* Mark the first roothub as being USB 2.0.
> 		 * The xHCI driver will register the USB 3.0 roothub.
> 		 */
> 		hcd->speed = HCD_USB2;
> 		hcd->self.root_hub->speed = USB_SPEED_HIGH;
> 		/*
> 		 * USB 2.0 roothub under xHCI has an integrated TT,
> 		 * (rate matching hub) as opposed to having an OHCI/UHCI
> 		 * companion controller.
> 		 */
> 		hcd->has_tt = 1;
> 	} else {
> 		if (xhci->sbrn == 0x31) {
> 			xhci_info(xhci, "Host supports USB 3.1 Enhanced SuperSpeed\n");
> 			hcd->speed = HCD_USB31;
> 		}
> 		/* xHCI private pointer was set in xhci_pci_probe for the second
> 		 * registered roothub.
> 		 */
> 		return 0;
> 	}
> 
> 	mutex_init(&xhci->mutex);
> 	xhci->cap_regs = hcd->regs;
> 	xhci->op_regs = hcd->regs +
> 		HC_LENGTH(readl(&xhci->cap_regs->hc_capbase));
> 	xhci->run_regs = hcd->regs +
> 		(readl(&xhci->cap_regs->run_regs_off) & RTSOFF_MASK);
> 	/* Cache read-only capability registers */
> 	xhci->hcs_params1 = readl(&xhci->cap_regs->hcs_params1);
> 	xhci->hcs_params2 = readl(&xhci->cap_regs->hcs_params2);
> 	xhci->hcs_params3 = readl(&xhci->cap_regs->hcs_params3);
> 	xhci->hcc_params = readl(&xhci->cap_regs->hc_capbase);
> 	xhci->hci_version = HC_VERSION(xhci->hcc_params);
> 	xhci->hcc_params = readl(&xhci->cap_regs->hcc_params);
> 	if (xhci->hci_version > 0x100)
> 		xhci->hcc_params2 = readl(&xhci->cap_regs->hcc_params2);
> 	xhci_print_registers(xhci);
> 
> 	xhci->quirks |= quirks;
> 
> 	get_quirks(dev, xhci);
> 
> 	/* In xhci controllers which follow xhci 1.0 spec gives a spurious
> 	 * success event after a short transfer. This quirk will ignore such
> 	 * spurious event.
> 	 */
> 	if (xhci->hci_version > 0x96)
> 		xhci->quirks |= XHCI_SPURIOUS_SUCCESS;
> 
> 	/* Make sure the HC is halted. */
> 	retval = xhci_halt(xhci);
> 	if (retval)
> 		return retval;
> 
> 	xhci_dbg(xhci, "Resetting HCD\n");
> 	/* Reset the internal HC memory state and registers. */
> 	retval = xhci_reset(xhci);
> 	if (retval)
> 		return retval;
> 	xhci_dbg(xhci, "Reset complete\n");
> 
> 	/* Set dma_mask and coherent_dma_mask to 64-bits,
> 	 * if xHC supports 64-bit addressing */
> 	if (HCC_64BIT_ADDR(xhci->hcc_params) &&
> 			!dma_set_mask(dev, DMA_BIT_MASK(64))) {
> 		xhci_dbg(xhci, "Enabling 64-bit DMA addresses.\n");
> 		dma_set_coherent_mask(dev, DMA_BIT_MASK(64));
> 	} else {
> 		/*
> 		 * This is to avoid error in cases where a 32-bit USB
> 		 * controller is used on a 64-bit capable system.
> 		 */
> 		retval = dma_set_mask(dev, DMA_BIT_MASK(32));
> 		if (retval)
> 			return retval;
> 		xhci_dbg(xhci, "Enabling 32-bit DMA addresses.\n");
> 		dma_set_coherent_mask(dev, DMA_BIT_MASK(32));
> 	}
> 
> 	xhci_dbg(xhci, "Calling HCD init\n");
> 	/* Initialize HCD and host controller data structures. */
> 	retval = xhci_init(hcd);
> 	if (retval)
> 		return retval;
> 	xhci_dbg(xhci, "Called HCD init\n");
> 
> 	xhci_info(xhci, "hcc params 0x%08x hci version 0x%x quirks 0x%08x\n",
> 		  xhci->hcc_params, xhci->hci_version, xhci->quirks);
> 
> 	return 0;
> }
> EXPORT_SYMBOL_GPL(xhci_gen_setup);
> 
> static const struct hc_driver xhci_hc_driver = {
> 	.description =		"xhci-hcd",
> 	.product_desc =		"xHCI Host Controller",
> 	.hcd_priv_size =	sizeof(struct xhci_hcd),
> 
> 	/*
> 	 * generic hardware linkage
> 	 */
> 	.irq =			xhci_irq,
> 	.flags =		HCD_MEMORY | HCD_USB3 | HCD_SHARED,
> 
> 	/*
> 	 * basic lifecycle operations
> 	 */
> 	.reset =		NULL, /* set in xhci_init_driver() */
> 	.start =		xhci_run,
> 	.stop =			xhci_stop,
> 	.shutdown =		xhci_shutdown,
> 
> 	/*
> 	 * managing i/o requests and associated device resources
> 	 */
> 	.urb_enqueue =		xhci_urb_enqueue,
> 	.urb_dequeue =		xhci_urb_dequeue,
> 	.alloc_dev =		xhci_alloc_dev,
> 	.free_dev =		xhci_free_dev,
> 	.alloc_streams =	xhci_alloc_streams,
> 	.free_streams =		xhci_free_streams,
> 	.add_endpoint =		xhci_add_endpoint,
> 	.drop_endpoint =	xhci_drop_endpoint,
> 	.endpoint_reset =	xhci_endpoint_reset,
> 	.check_bandwidth =	xhci_check_bandwidth,
> 	.reset_bandwidth =	xhci_reset_bandwidth,
> 	.address_device =	xhci_address_device,
> 	.enable_device =	xhci_enable_device,
> 	.update_hub_device =	xhci_update_hub_device,
> 	.reset_device =		xhci_discover_or_reset_device,
> 
> 	/*
> 	 * scheduling support
> 	 */
> 	.get_frame_number =	xhci_get_frame,
> 
> 	/*
> 	 * root hub support
> 	 */
> 	.hub_control =		xhci_hub_control,
> 	.hub_status_data =	xhci_hub_status_data,
> 	.bus_suspend =		xhci_bus_suspend,
> 	.bus_resume =		xhci_bus_resume,
> 
> 	/*
> 	 * call back when device connected and addressed
> 	 */
> 	.update_device =        xhci_update_device,
> 	.set_usb2_hw_lpm =	xhci_set_usb2_hardware_lpm,
> 	.enable_usb3_lpm_timeout =	xhci_enable_usb3_lpm_timeout,
> 	.disable_usb3_lpm_timeout =	xhci_disable_usb3_lpm_timeout,
> 	.find_raw_port_number =	xhci_find_raw_port_number,
> };
> 
> void xhci_init_driver(struct hc_driver *drv,
> 		      const struct xhci_driver_overrides *over)
> {
> 	BUG_ON(!over);
> 
> 	/* Copy the generic table to drv then apply the overrides */
> 	*drv = xhci_hc_driver;
> 
> 	if (over) {
> 		drv->hcd_priv_size += over->extra_priv_size;
> 		if (over->reset)
> 			drv->reset = over->reset;
> 		if (over->start)
> 			drv->start = over->start;
> 	}
> }
> EXPORT_SYMBOL_GPL(xhci_init_driver);
> 
> MODULE_DESCRIPTION(DRIVER_DESC);
> MODULE_AUTHOR(DRIVER_AUTHOR);
> MODULE_LICENSE("GPL");
> 
> static int __init xhci_hcd_init(void)
> {
> 	/*
> 	 * Check the compiler generated sizes of structures that must be laid
> 	 * out in specific ways for hardware access.
> 	 */
> 	BUILD_BUG_ON(sizeof(struct xhci_doorbell_array) != 256*32/8);
> 	BUILD_BUG_ON(sizeof(struct xhci_slot_ctx) != 8*32/8);
> 	BUILD_BUG_ON(sizeof(struct xhci_ep_ctx) != 8*32/8);
> 	/* xhci_device_control has eight fields, and also
> 	 * embeds one xhci_slot_ctx and 31 xhci_ep_ctx
> 	 */
> 	BUILD_BUG_ON(sizeof(struct xhci_stream_ctx) != 4*32/8);
> 	BUILD_BUG_ON(sizeof(union xhci_trb) != 4*32/8);
> 	BUILD_BUG_ON(sizeof(struct xhci_erst_entry) != 4*32/8);
> 	BUILD_BUG_ON(sizeof(struct xhci_cap_regs) != 8*32/8);
> 	BUILD_BUG_ON(sizeof(struct xhci_intr_reg) != 8*32/8);
> 	/* xhci_run_regs has eight fields and embeds 128 xhci_intr_regs */
> 	BUILD_BUG_ON(sizeof(struct xhci_run_regs) != (8+8*128)*32/8);
> 
> 	if (usb_disabled())
> 		return -ENODEV;
> 
> 	return 0;
> }
> 
> /*
>  * If an init function is provided, an exit function must also be provided
>  * to allow module unload.
>  */
> static void __exit xhci_hcd_fini(void) { }
> 
diff -r xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/.gitignore /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/.gitignore
18,20c18
< *.ko.unsigned
< *.ko.digest
< *.ko.digest.sig
---
> *.ko.*
56a55,58
> /arch/arm64/boot/uImage
> Image
> compile.sh
> 
107c109
< extra_certificates
---
> #extra_certificates
111a114,119
> 
> certs/signing_key.pem
> certs/signing_key.x509
> 
> 
> 
Only in /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/include/uapi/linux/netfilter: HVN5U00~.H
diff -r xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/include/uapi/linux/netfilter/xt_connmark.h /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/include/uapi/linux/netfilter/xt_connmark.h
1,2c1,2
< #ifndef _XT_CONNMARK_H
< #define _XT_CONNMARK_H
---
> #ifndef _XT_CONNMARK_H_target
> #define _XT_CONNMARK_H_target
4c4
< #include <linux/types.h>
---
> #include <linux/netfilter/xt_connmark.h>
6,31c6
< /* Copyright (C) 2002,2004 MARA Systems AB <http://www.marasystems.com>
<  * by Henrik Nordstrom <hno@marasystems.com>
<  *
<  * This program is free software; you can redistribute it and/or modify
<  * it under the terms of the GNU General Public License as published by
<  * the Free Software Foundation; either version 2 of the License, or
<  * (at your option) any later version.
<  */
< 
< enum {
< 	XT_CONNMARK_SET = 0,
< 	XT_CONNMARK_SAVE,
< 	XT_CONNMARK_RESTORE
< };
< 
< struct xt_connmark_tginfo1 {
< 	__u32 ctmark, ctmask, nfmask;
< 	__u8 mode;
< };
< 
< struct xt_connmark_mtinfo1 {
< 	__u32 mark, mask;
< 	__u8 invert;
< };
< 
< #endif /*_XT_CONNMARK_H*/
---
> #endif /*_XT_CONNMARK_H_target*/
diff -r xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/include/uapi/linux/netfilter/xt_dscp.h /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/include/uapi/linux/netfilter/xt_dscp.h
1c1
< /* x_tables module for matching the IPv4/IPv6 DSCP field
---
> /* x_tables module for setting the IPv4/IPv6 DSCP field
3a4
>  * based on ipt_FTOS.c (C) 2000 by Matthew G. Marsh <mgm@paktronix.com>
8c9
<  * xt_dscp.h,v 1.3 2002/08/05 19:00:21 laforge Exp
---
>  * xt_DSCP.h,v 1.7 2002/03/14 12:03:13 laforge Exp
10,12c11,13
< #ifndef _XT_DSCP_H
< #define _XT_DSCP_H
< 
---
> #ifndef _XT_DSCP_TARGET_H
> #define _XT_DSCP_TARGET_H
> #include <linux/netfilter/xt_dscp.h>
15,20c16,17
< #define XT_DSCP_MASK	0xfc	/* 11111100 */
< #define XT_DSCP_SHIFT	2
< #define XT_DSCP_MAX	0x3f	/* 00111111 */
< 
< /* match info */
< struct xt_dscp_info {
---
> /* target info */
> struct xt_DSCP_info {
22d18
< 	__u8 invert;
25,26c21
< struct xt_tos_match_info {
< 	__u8 tos_mask;
---
> struct xt_tos_target_info {
28c23
< 	__u8 invert;
---
> 	__u8 tos_mask;
31c26
< #endif /* _XT_DSCP_H */
---
> #endif /* _XT_DSCP_TARGET_H */
diff -r xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/include/uapi/linux/netfilter/xt_DSCP.h /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/include/uapi/linux/netfilter/xt_DSCP.h
1c1
< /* x_tables module for setting the IPv4/IPv6 DSCP field
---
> /* x_tables module for matching the IPv4/IPv6 DSCP field
4d3
<  * based on ipt_FTOS.c (C) 2000 by Matthew G. Marsh <mgm@paktronix.com>
9c8
<  * xt_DSCP.h,v 1.7 2002/03/14 12:03:13 laforge Exp
---
>  * xt_dscp.h,v 1.3 2002/08/05 19:00:21 laforge Exp
11,13c10,12
< #ifndef _XT_DSCP_TARGET_H
< #define _XT_DSCP_TARGET_H
< #include <linux/netfilter/xt_dscp.h>
---
> #ifndef _XT_DSCP_H
> #define _XT_DSCP_H
> 
16,17c15,20
< /* target info */
< struct xt_DSCP_info {
---
> #define XT_DSCP_MASK	0xfc	/* 11111100 */
> #define XT_DSCP_SHIFT	2
> #define XT_DSCP_MAX	0x3f	/* 00111111 */
> 
> /* match info */
> struct xt_dscp_info {
18a22
> 	__u8 invert;
21,22c25
< struct xt_tos_target_info {
< 	__u8 tos_value;
---
> struct xt_tos_match_info {
23a27,28
> 	__u8 tos_value;
> 	__u8 invert;
26c31
< #endif /* _XT_DSCP_TARGET_H */
---
> #endif /* _XT_DSCP_H */
diff -r xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/include/uapi/linux/netfilter/xt_mark.h /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/include/uapi/linux/netfilter/xt_mark.h
1,2c1,2
< #ifndef _XT_MARK_H
< #define _XT_MARK_H
---
> #ifndef _XT_MARK_H_target
> #define _XT_MARK_H_target
4c4
< #include <linux/types.h>
---
> #include <linux/netfilter/xt_mark.h>
6,15c6
< struct xt_mark_tginfo2 {
< 	__u32 mark, mask;
< };
< 
< struct xt_mark_mtinfo1 {
< 	__u32 mark, mask;
< 	__u8 invert;
< };
< 
< #endif /*_XT_MARK_H*/
---
> #endif /*_XT_MARK_H_target */
diff -r xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/include/uapi/linux/netfilter/xt_MARK.h /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/include/uapi/linux/netfilter/xt_MARK.h
1,2c1,2
< #ifndef _XT_MARK_H_target
< #define _XT_MARK_H_target
---
> #ifndef _XT_MARK_H
> #define _XT_MARK_H
4c4
< #include <linux/netfilter/xt_mark.h>
---
> #include <linux/types.h>
6c6,15
< #endif /*_XT_MARK_H_target */
---
> struct xt_mark_tginfo2 {
> 	__u32 mark, mask;
> };
> 
> struct xt_mark_mtinfo1 {
> 	__u32 mark, mask;
> 	__u8 invert;
> };
> 
> #endif /*_XT_MARK_H*/
diff -r xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/include/uapi/linux/netfilter/xt_rateest.h /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/include/uapi/linux/netfilter/xt_rateest.h
1,2c1,2
< #ifndef _XT_RATEEST_MATCH_H
< #define _XT_RATEEST_MATCH_H
---
> #ifndef _XT_RATEEST_TARGET_H
> #define _XT_RATEEST_TARGET_H
7,31c7,10
< enum xt_rateest_match_flags {
< 	XT_RATEEST_MATCH_INVERT	= 1<<0,
< 	XT_RATEEST_MATCH_ABS	= 1<<1,
< 	XT_RATEEST_MATCH_REL	= 1<<2,
< 	XT_RATEEST_MATCH_DELTA	= 1<<3,
< 	XT_RATEEST_MATCH_BPS	= 1<<4,
< 	XT_RATEEST_MATCH_PPS	= 1<<5,
< };
< 
< enum xt_rateest_match_mode {
< 	XT_RATEEST_MATCH_NONE,
< 	XT_RATEEST_MATCH_EQ,
< 	XT_RATEEST_MATCH_LT,
< 	XT_RATEEST_MATCH_GT,
< };
< 
< struct xt_rateest_match_info {
< 	char			name1[IFNAMSIZ];
< 	char			name2[IFNAMSIZ];
< 	__u16		flags;
< 	__u16		mode;
< 	__u32		bps1;
< 	__u32		pps1;
< 	__u32		bps2;
< 	__u32		pps2;
---
> struct xt_rateest_target_info {
> 	char			name[IFNAMSIZ];
> 	__s8			interval;
> 	__u8		ewma_log;
34,35c13
< 	struct xt_rateest	*est1 __attribute__((aligned(8)));
< 	struct xt_rateest	*est2 __attribute__((aligned(8)));
---
> 	struct xt_rateest	*est __attribute__((aligned(8)));
38c16
< #endif /* _XT_RATEEST_MATCH_H */
---
> #endif /* _XT_RATEEST_TARGET_H */
diff -r xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/include/uapi/linux/netfilter/xt_RATEEST.h /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/include/uapi/linux/netfilter/xt_RATEEST.h
1,2c1,2
< #ifndef _XT_RATEEST_TARGET_H
< #define _XT_RATEEST_TARGET_H
---
> #ifndef _XT_RATEEST_MATCH_H
> #define _XT_RATEEST_MATCH_H
7,10c7,31
< struct xt_rateest_target_info {
< 	char			name[IFNAMSIZ];
< 	__s8			interval;
< 	__u8		ewma_log;
---
> enum xt_rateest_match_flags {
> 	XT_RATEEST_MATCH_INVERT	= 1<<0,
> 	XT_RATEEST_MATCH_ABS	= 1<<1,
> 	XT_RATEEST_MATCH_REL	= 1<<2,
> 	XT_RATEEST_MATCH_DELTA	= 1<<3,
> 	XT_RATEEST_MATCH_BPS	= 1<<4,
> 	XT_RATEEST_MATCH_PPS	= 1<<5,
> };
> 
> enum xt_rateest_match_mode {
> 	XT_RATEEST_MATCH_NONE,
> 	XT_RATEEST_MATCH_EQ,
> 	XT_RATEEST_MATCH_LT,
> 	XT_RATEEST_MATCH_GT,
> };
> 
> struct xt_rateest_match_info {
> 	char			name1[IFNAMSIZ];
> 	char			name2[IFNAMSIZ];
> 	__u16		flags;
> 	__u16		mode;
> 	__u32		bps1;
> 	__u32		pps1;
> 	__u32		bps2;
> 	__u32		pps2;
13c34,35
< 	struct xt_rateest	*est __attribute__((aligned(8)));
---
> 	struct xt_rateest	*est1 __attribute__((aligned(8)));
> 	struct xt_rateest	*est2 __attribute__((aligned(8)));
16c38
< #endif /* _XT_RATEEST_TARGET_H */
---
> #endif /* _XT_RATEEST_MATCH_H */
Only in /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/include/uapi/linux/netfilter: XT_TCP~3.H
diff -r xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/include/uapi/linux/netfilter/xt_tcpmss.h /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/include/uapi/linux/netfilter/xt_tcpmss.h
1,2c1,2
< #ifndef _XT_TCPMSS_MATCH_H
< #define _XT_TCPMSS_MATCH_H
---
> #ifndef _XT_TCPMSS_H
> #define _XT_TCPMSS_H
6,8c6,7
< struct xt_tcpmss_match_info {
<     __u16 mss_min, mss_max;
<     __u8 invert;
---
> struct xt_tcpmss_info {
> 	__u16 mss;
11c10,12
< #endif /*_XT_TCPMSS_MATCH_H*/
---
> #define XT_TCPMSS_CLAMP_PMTU 0xffff
> 
> #endif /* _XT_TCPMSS_H */
diff -r xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/include/uapi/linux/netfilter_ipv4/ipt_ecn.h /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/include/uapi/linux/netfilter_ipv4/ipt_ecn.h
1,2c1,10
< #ifndef _IPT_ECN_H
< #define _IPT_ECN_H
---
> /* Header file for iptables ipt_ECN target
>  *
>  * (C) 2002 by Harald Welte <laforge@gnumonks.org>
>  *
>  * This software is distributed under GNU GPL v2, 1991
>  * 
>  * ipt_ECN.h,v 1.3 2002/05/29 12:17:40 laforge Exp
> */
> #ifndef _IPT_ECN_TARGET_H
> #define _IPT_ECN_TARGET_H
4,5c12,13
< #include <linux/netfilter/xt_ecn.h>
< #define ipt_ecn_info xt_ecn_info
---
> #include <linux/types.h>
> #include <linux/netfilter/xt_DSCP.h>
7,12c15,30
< enum {
< 	IPT_ECN_IP_MASK       = XT_ECN_IP_MASK,
< 	IPT_ECN_OP_MATCH_IP   = XT_ECN_OP_MATCH_IP,
< 	IPT_ECN_OP_MATCH_ECE  = XT_ECN_OP_MATCH_ECE,
< 	IPT_ECN_OP_MATCH_CWR  = XT_ECN_OP_MATCH_CWR,
< 	IPT_ECN_OP_MATCH_MASK = XT_ECN_OP_MATCH_MASK,
---
> #define IPT_ECN_IP_MASK	(~XT_DSCP_MASK)
> 
> #define IPT_ECN_OP_SET_IP	0x01	/* set ECN bits of IPv4 header */
> #define IPT_ECN_OP_SET_ECE	0x10	/* set ECE bit of TCP header */
> #define IPT_ECN_OP_SET_CWR	0x20	/* set CWR bit of TCP header */
> 
> #define IPT_ECN_OP_MASK		0xce
> 
> struct ipt_ECN_info {
> 	__u8 operation;	/* bitset of operations */
> 	__u8 ip_ect;	/* ECT codepoint of IPv4 header, pre-shifted */
> 	union {
> 		struct {
> 			__u8 ece:1, cwr:1; /* TCP ECT bits */
> 		} tcp;
> 	} proto;
15c33
< #endif /* IPT_ECN_H */
---
> #endif /* _IPT_ECN_TARGET_H */
diff -r xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/include/uapi/linux/netfilter_ipv4/ipt_ECN.h /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/include/uapi/linux/netfilter_ipv4/ipt_ECN.h
1,10c1,2
< /* Header file for iptables ipt_ECN target
<  *
<  * (C) 2002 by Harald Welte <laforge@gnumonks.org>
<  *
<  * This software is distributed under GNU GPL v2, 1991
<  * 
<  * ipt_ECN.h,v 1.3 2002/05/29 12:17:40 laforge Exp
< */
< #ifndef _IPT_ECN_TARGET_H
< #define _IPT_ECN_TARGET_H
---
> #ifndef _IPT_ECN_H
> #define _IPT_ECN_H
12,13c4,5
< #include <linux/types.h>
< #include <linux/netfilter/xt_DSCP.h>
---
> #include <linux/netfilter/xt_ecn.h>
> #define ipt_ecn_info xt_ecn_info
15,30c7,12
< #define IPT_ECN_IP_MASK	(~XT_DSCP_MASK)
< 
< #define IPT_ECN_OP_SET_IP	0x01	/* set ECN bits of IPv4 header */
< #define IPT_ECN_OP_SET_ECE	0x10	/* set ECE bit of TCP header */
< #define IPT_ECN_OP_SET_CWR	0x20	/* set CWR bit of TCP header */
< 
< #define IPT_ECN_OP_MASK		0xce
< 
< struct ipt_ECN_info {
< 	__u8 operation;	/* bitset of operations */
< 	__u8 ip_ect;	/* ECT codepoint of IPv4 header, pre-shifted */
< 	union {
< 		struct {
< 			__u8 ece:1, cwr:1; /* TCP ECT bits */
< 		} tcp;
< 	} proto;
---
> enum {
> 	IPT_ECN_IP_MASK       = XT_ECN_IP_MASK,
> 	IPT_ECN_OP_MATCH_IP   = XT_ECN_OP_MATCH_IP,
> 	IPT_ECN_OP_MATCH_ECE  = XT_ECN_OP_MATCH_ECE,
> 	IPT_ECN_OP_MATCH_CWR  = XT_ECN_OP_MATCH_CWR,
> 	IPT_ECN_OP_MATCH_MASK = XT_ECN_OP_MATCH_MASK,
33c15
< #endif /* _IPT_ECN_TARGET_H */
---
> #endif /* IPT_ECN_H */
diff -r xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/include/uapi/linux/netfilter_ipv4/ipt_ttl.h /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/include/uapi/linux/netfilter_ipv4/ipt_ttl.h
1,2c1,2
< /* IP tables module for matching the value of the TTL
<  * (C) 2000 by Harald Welte <laforge@gnumonks.org> */
---
> /* TTL modification module for IP tables
>  * (C) 2000 by Harald Welte <laforge@netfilter.org> */
10,13c10,12
< 	IPT_TTL_EQ = 0,		/* equals */
< 	IPT_TTL_NE,		/* not equals */
< 	IPT_TTL_LT,		/* less than */
< 	IPT_TTL_GT,		/* greater than */
---
> 	IPT_TTL_SET = 0,
> 	IPT_TTL_INC,
> 	IPT_TTL_DEC
15a15
> #define IPT_TTL_MAXMODE	IPT_TTL_DEC
17c17
< struct ipt_ttl_info {
---
> struct ipt_TTL_info {
diff -r xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/include/uapi/linux/netfilter_ipv4/ipt_TTL.h /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/include/uapi/linux/netfilter_ipv4/ipt_TTL.h
1,2c1,2
< /* TTL modification module for IP tables
<  * (C) 2000 by Harald Welte <laforge@netfilter.org> */
---
> /* IP tables module for matching the value of the TTL
>  * (C) 2000 by Harald Welte <laforge@gnumonks.org> */
10,12c10,13
< 	IPT_TTL_SET = 0,
< 	IPT_TTL_INC,
< 	IPT_TTL_DEC
---
> 	IPT_TTL_EQ = 0,		/* equals */
> 	IPT_TTL_NE,		/* not equals */
> 	IPT_TTL_LT,		/* less than */
> 	IPT_TTL_GT,		/* greater than */
15d15
< #define IPT_TTL_MAXMODE	IPT_TTL_DEC
17c17
< struct ipt_TTL_info {
---
> struct ipt_ttl_info {
diff -r xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/include/uapi/linux/netfilter_ipv6/ip6t_hl.h /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/include/uapi/linux/netfilter_ipv6/ip6t_hl.h
1c1
< /* ip6tables module for matching the Hop Limit value
---
> /* Hop Limit modification module for ip6tables
3c3
<  * Based on HW's ttl module */
---
>  * Based on HW's TTL module */
11,14c11,13
< 	IP6T_HL_EQ = 0,		/* equals */
< 	IP6T_HL_NE,		/* not equals */
< 	IP6T_HL_LT,		/* less than */
< 	IP6T_HL_GT,		/* greater than */
---
> 	IP6T_HL_SET = 0,
> 	IP6T_HL_INC,
> 	IP6T_HL_DEC
16a16
> #define IP6T_HL_MAXMODE	IP6T_HL_DEC
18c18
< struct ip6t_hl_info {
---
> struct ip6t_HL_info {
diff -r xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/include/uapi/linux/netfilter_ipv6/ip6t_HL.h /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/include/uapi/linux/netfilter_ipv6/ip6t_HL.h
1c1
< /* Hop Limit modification module for ip6tables
---
> /* ip6tables module for matching the Hop Limit value
3c3
<  * Based on HW's TTL module */
---
>  * Based on HW's ttl module */
11,13c11,14
< 	IP6T_HL_SET = 0,
< 	IP6T_HL_INC,
< 	IP6T_HL_DEC
---
> 	IP6T_HL_EQ = 0,		/* equals */
> 	IP6T_HL_NE,		/* not equals */
> 	IP6T_HL_LT,		/* less than */
> 	IP6T_HL_GT,		/* greater than */
16d16
< #define IP6T_HL_MAXMODE	IP6T_HL_DEC
18c18
< struct ip6t_HL_info {
---
> struct ip6t_hl_info {
diff -r xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/net/netfilter/xt_dscp.c /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/net/netfilter/xt_dscp.c
1c1
< /* IP tables module for matching the value of the IPv4/IPv6 DSCP field
---
> /* x_tables module for setting the IPv4/IPv6 DSCP field, Version 1.8
3a4
>  * based on ipt_FTOS.c (C) 2000 by Matthew G. Marsh <mgm@paktronix.com>
8c9,11
<  */
---
>  *
>  * See RFC2474 for a description of the DSCP field within the IP Header.
> */
17c20
< #include <linux/netfilter/xt_dscp.h>
---
> #include <linux/netfilter/xt_DSCP.h>
20c23
< MODULE_DESCRIPTION("Xtables: DSCP/TOS field match");
---
> MODULE_DESCRIPTION("Xtables: DSCP/TOS field modification");
22,25c25,28
< MODULE_ALIAS("ipt_dscp");
< MODULE_ALIAS("ip6t_dscp");
< MODULE_ALIAS("ipt_tos");
< MODULE_ALIAS("ip6t_tos");
---
> MODULE_ALIAS("ipt_DSCP");
> MODULE_ALIAS("ip6t_DSCP");
> MODULE_ALIAS("ipt_TOS");
> MODULE_ALIAS("ip6t_TOS");
27,28c30,31
< static bool
< dscp_mt(const struct sk_buff *skb, struct xt_action_param *par)
---
> static unsigned int
> dscp_tg(struct sk_buff *skb, const struct xt_action_param *par)
30c33
< 	const struct xt_dscp_info *info = par->matchinfo;
---
> 	const struct xt_DSCP_info *dinfo = par->targinfo;
33c36,45
< 	return (dscp == info->dscp) ^ !!info->invert;
---
> 	if (dscp != dinfo->dscp) {
> 		if (!skb_make_writable(skb, sizeof(struct iphdr)))
> 			return NF_DROP;
> 
> 		ipv4_change_dsfield(ip_hdr(skb),
> 				    (__force __u8)(~XT_DSCP_MASK),
> 				    dinfo->dscp << XT_DSCP_SHIFT);
> 
> 	}
> 	return XT_CONTINUE;
36,37c48,49
< static bool
< dscp_mt6(const struct sk_buff *skb, struct xt_action_param *par)
---
> static unsigned int
> dscp_tg6(struct sk_buff *skb, const struct xt_action_param *par)
39c51
< 	const struct xt_dscp_info *info = par->matchinfo;
---
> 	const struct xt_DSCP_info *dinfo = par->targinfo;
42c54,62
< 	return (dscp == info->dscp) ^ !!info->invert;
---
> 	if (dscp != dinfo->dscp) {
> 		if (!skb_make_writable(skb, sizeof(struct ipv6hdr)))
> 			return NF_DROP;
> 
> 		ipv6_change_dsfield(ipv6_hdr(skb),
> 				    (__force __u8)(~XT_DSCP_MASK),
> 				    dinfo->dscp << XT_DSCP_SHIFT);
> 	}
> 	return XT_CONTINUE;
45c65
< static int dscp_mt_check(const struct xt_mtchk_param *par)
---
> static int dscp_tg_check(const struct xt_tgchk_param *par)
47c67
< 	const struct xt_dscp_info *info = par->matchinfo;
---
> 	const struct xt_DSCP_info *info = par->targinfo;
53d72
< 
57c76,77
< static bool tos_mt(const struct sk_buff *skb, struct xt_action_param *par)
---
> static unsigned int
> tos_tg(struct sk_buff *skb, const struct xt_action_param *par)
59c79,111
< 	const struct xt_tos_match_info *info = par->matchinfo;
---
> 	const struct xt_tos_target_info *info = par->targinfo;
> 	struct iphdr *iph = ip_hdr(skb);
> 	u_int8_t orig, nv;
> 
> 	orig = ipv4_get_dsfield(iph);
> 	nv   = (orig & ~info->tos_mask) ^ info->tos_value;
> 
> 	if (orig != nv) {
> 		if (!skb_make_writable(skb, sizeof(struct iphdr)))
> 			return NF_DROP;
> 		iph = ip_hdr(skb);
> 		ipv4_change_dsfield(iph, 0, nv);
> 	}
> 
> 	return XT_CONTINUE;
> }
> 
> static unsigned int
> tos_tg6(struct sk_buff *skb, const struct xt_action_param *par)
> {
> 	const struct xt_tos_target_info *info = par->targinfo;
> 	struct ipv6hdr *iph = ipv6_hdr(skb);
> 	u_int8_t orig, nv;
> 
> 	orig = ipv6_get_dsfield(iph);
> 	nv   = (orig & ~info->tos_mask) ^ info->tos_value;
> 
> 	if (orig != nv) {
> 		if (!skb_make_writable(skb, sizeof(struct iphdr)))
> 			return NF_DROP;
> 		iph = ipv6_hdr(skb);
> 		ipv6_change_dsfield(iph, 0, nv);
> 	}
61,66c113
< 	if (par->family == NFPROTO_IPV4)
< 		return ((ip_hdr(skb)->tos & info->tos_mask) ==
< 		       info->tos_value) ^ !!info->invert;
< 	else
< 		return ((ipv6_get_dsfield(ipv6_hdr(skb)) & info->tos_mask) ==
< 		       info->tos_value) ^ !!info->invert;
---
> 	return XT_CONTINUE;
69c116
< static struct xt_match dscp_mt_reg[] __read_mostly = {
---
> static struct xt_target dscp_tg_reg[] __read_mostly = {
71c118
< 		.name		= "dscp",
---
> 		.name		= "DSCP",
73,75c120,123
< 		.checkentry	= dscp_mt_check,
< 		.match		= dscp_mt,
< 		.matchsize	= sizeof(struct xt_dscp_info),
---
> 		.checkentry	= dscp_tg_check,
> 		.target		= dscp_tg,
> 		.targetsize	= sizeof(struct xt_DSCP_info),
> 		.table		= "mangle",
79c127
< 		.name		= "dscp",
---
> 		.name		= "DSCP",
81,83c129,132
< 		.checkentry	= dscp_mt_check,
< 		.match		= dscp_mt6,
< 		.matchsize	= sizeof(struct xt_dscp_info),
---
> 		.checkentry	= dscp_tg_check,
> 		.target		= dscp_tg6,
> 		.targetsize	= sizeof(struct xt_DSCP_info),
> 		.table		= "mangle",
87c136
< 		.name		= "tos",
---
> 		.name		= "TOS",
90,91c139,141
< 		.match		= tos_mt,
< 		.matchsize	= sizeof(struct xt_tos_match_info),
---
> 		.table		= "mangle",
> 		.target		= tos_tg,
> 		.targetsize	= sizeof(struct xt_tos_target_info),
95c145
< 		.name		= "tos",
---
> 		.name		= "TOS",
98,99c148,150
< 		.match		= tos_mt,
< 		.matchsize	= sizeof(struct xt_tos_match_info),
---
> 		.table		= "mangle",
> 		.target		= tos_tg6,
> 		.targetsize	= sizeof(struct xt_tos_target_info),
104c155
< static int __init dscp_mt_init(void)
---
> static int __init dscp_tg_init(void)
106c157
< 	return xt_register_matches(dscp_mt_reg, ARRAY_SIZE(dscp_mt_reg));
---
> 	return xt_register_targets(dscp_tg_reg, ARRAY_SIZE(dscp_tg_reg));
109c160
< static void __exit dscp_mt_exit(void)
---
> static void __exit dscp_tg_exit(void)
111c162
< 	xt_unregister_matches(dscp_mt_reg, ARRAY_SIZE(dscp_mt_reg));
---
> 	xt_unregister_targets(dscp_tg_reg, ARRAY_SIZE(dscp_tg_reg));
114,115c165,166
< module_init(dscp_mt_init);
< module_exit(dscp_mt_exit);
---
> module_init(dscp_tg_init);
> module_exit(dscp_tg_exit);
diff -r xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/net/netfilter/xt_DSCP.c /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/net/netfilter/xt_DSCP.c
1c1
< /* x_tables module for setting the IPv4/IPv6 DSCP field, Version 1.8
---
> /* IP tables module for matching the value of the IPv4/IPv6 DSCP field
4d3
<  * based on ipt_FTOS.c (C) 2000 by Matthew G. Marsh <mgm@paktronix.com>
9,11c8
<  *
<  * See RFC2474 for a description of the DSCP field within the IP Header.
< */
---
>  */
20c17
< #include <linux/netfilter/xt_DSCP.h>
---
> #include <linux/netfilter/xt_dscp.h>
23c20
< MODULE_DESCRIPTION("Xtables: DSCP/TOS field modification");
---
> MODULE_DESCRIPTION("Xtables: DSCP/TOS field match");
25,28c22,25
< MODULE_ALIAS("ipt_DSCP");
< MODULE_ALIAS("ip6t_DSCP");
< MODULE_ALIAS("ipt_TOS");
< MODULE_ALIAS("ip6t_TOS");
---
> MODULE_ALIAS("ipt_dscp");
> MODULE_ALIAS("ip6t_dscp");
> MODULE_ALIAS("ipt_tos");
> MODULE_ALIAS("ip6t_tos");
30,31c27,28
< static unsigned int
< dscp_tg(struct sk_buff *skb, const struct xt_action_param *par)
---
> static bool
> dscp_mt(const struct sk_buff *skb, struct xt_action_param *par)
33c30
< 	const struct xt_DSCP_info *dinfo = par->targinfo;
---
> 	const struct xt_dscp_info *info = par->matchinfo;
36,45c33
< 	if (dscp != dinfo->dscp) {
< 		if (!skb_make_writable(skb, sizeof(struct iphdr)))
< 			return NF_DROP;
< 
< 		ipv4_change_dsfield(ip_hdr(skb),
< 				    (__force __u8)(~XT_DSCP_MASK),
< 				    dinfo->dscp << XT_DSCP_SHIFT);
< 
< 	}
< 	return XT_CONTINUE;
---
> 	return (dscp == info->dscp) ^ !!info->invert;
48,49c36,37
< static unsigned int
< dscp_tg6(struct sk_buff *skb, const struct xt_action_param *par)
---
> static bool
> dscp_mt6(const struct sk_buff *skb, struct xt_action_param *par)
51c39
< 	const struct xt_DSCP_info *dinfo = par->targinfo;
---
> 	const struct xt_dscp_info *info = par->matchinfo;
54,62c42
< 	if (dscp != dinfo->dscp) {
< 		if (!skb_make_writable(skb, sizeof(struct ipv6hdr)))
< 			return NF_DROP;
< 
< 		ipv6_change_dsfield(ipv6_hdr(skb),
< 				    (__force __u8)(~XT_DSCP_MASK),
< 				    dinfo->dscp << XT_DSCP_SHIFT);
< 	}
< 	return XT_CONTINUE;
---
> 	return (dscp == info->dscp) ^ !!info->invert;
65c45
< static int dscp_tg_check(const struct xt_tgchk_param *par)
---
> static int dscp_mt_check(const struct xt_mtchk_param *par)
67c47
< 	const struct xt_DSCP_info *info = par->targinfo;
---
> 	const struct xt_dscp_info *info = par->matchinfo;
73,74d52
< 	return 0;
< }
76,93c54
< static unsigned int
< tos_tg(struct sk_buff *skb, const struct xt_action_param *par)
< {
< 	const struct xt_tos_target_info *info = par->targinfo;
< 	struct iphdr *iph = ip_hdr(skb);
< 	u_int8_t orig, nv;
< 
< 	orig = ipv4_get_dsfield(iph);
< 	nv   = (orig & ~info->tos_mask) ^ info->tos_value;
< 
< 	if (orig != nv) {
< 		if (!skb_make_writable(skb, sizeof(struct iphdr)))
< 			return NF_DROP;
< 		iph = ip_hdr(skb);
< 		ipv4_change_dsfield(iph, 0, nv);
< 	}
< 
< 	return XT_CONTINUE;
---
> 	return 0;
96,97c57
< static unsigned int
< tos_tg6(struct sk_buff *skb, const struct xt_action_param *par)
---
> static bool tos_mt(const struct sk_buff *skb, struct xt_action_param *par)
99,111c59
< 	const struct xt_tos_target_info *info = par->targinfo;
< 	struct ipv6hdr *iph = ipv6_hdr(skb);
< 	u_int8_t orig, nv;
< 
< 	orig = ipv6_get_dsfield(iph);
< 	nv   = (orig & ~info->tos_mask) ^ info->tos_value;
< 
< 	if (orig != nv) {
< 		if (!skb_make_writable(skb, sizeof(struct iphdr)))
< 			return NF_DROP;
< 		iph = ipv6_hdr(skb);
< 		ipv6_change_dsfield(iph, 0, nv);
< 	}
---
> 	const struct xt_tos_match_info *info = par->matchinfo;
113c61,66
< 	return XT_CONTINUE;
---
> 	if (par->family == NFPROTO_IPV4)
> 		return ((ip_hdr(skb)->tos & info->tos_mask) ==
> 		       info->tos_value) ^ !!info->invert;
> 	else
> 		return ((ipv6_get_dsfield(ipv6_hdr(skb)) & info->tos_mask) ==
> 		       info->tos_value) ^ !!info->invert;
116c69
< static struct xt_target dscp_tg_reg[] __read_mostly = {
---
> static struct xt_match dscp_mt_reg[] __read_mostly = {
118c71
< 		.name		= "DSCP",
---
> 		.name		= "dscp",
120,123c73,75
< 		.checkentry	= dscp_tg_check,
< 		.target		= dscp_tg,
< 		.targetsize	= sizeof(struct xt_DSCP_info),
< 		.table		= "mangle",
---
> 		.checkentry	= dscp_mt_check,
> 		.match		= dscp_mt,
> 		.matchsize	= sizeof(struct xt_dscp_info),
127c79
< 		.name		= "DSCP",
---
> 		.name		= "dscp",
129,132c81,83
< 		.checkentry	= dscp_tg_check,
< 		.target		= dscp_tg6,
< 		.targetsize	= sizeof(struct xt_DSCP_info),
< 		.table		= "mangle",
---
> 		.checkentry	= dscp_mt_check,
> 		.match		= dscp_mt6,
> 		.matchsize	= sizeof(struct xt_dscp_info),
136c87
< 		.name		= "TOS",
---
> 		.name		= "tos",
139,141c90,91
< 		.table		= "mangle",
< 		.target		= tos_tg,
< 		.targetsize	= sizeof(struct xt_tos_target_info),
---
> 		.match		= tos_mt,
> 		.matchsize	= sizeof(struct xt_tos_match_info),
145c95
< 		.name		= "TOS",
---
> 		.name		= "tos",
148,150c98,99
< 		.table		= "mangle",
< 		.target		= tos_tg6,
< 		.targetsize	= sizeof(struct xt_tos_target_info),
---
> 		.match		= tos_mt,
> 		.matchsize	= sizeof(struct xt_tos_match_info),
155c104
< static int __init dscp_tg_init(void)
---
> static int __init dscp_mt_init(void)
157c106
< 	return xt_register_targets(dscp_tg_reg, ARRAY_SIZE(dscp_tg_reg));
---
> 	return xt_register_matches(dscp_mt_reg, ARRAY_SIZE(dscp_mt_reg));
160c109
< static void __exit dscp_tg_exit(void)
---
> static void __exit dscp_mt_exit(void)
162c111
< 	xt_unregister_targets(dscp_tg_reg, ARRAY_SIZE(dscp_tg_reg));
---
> 	xt_unregister_matches(dscp_mt_reg, ARRAY_SIZE(dscp_mt_reg));
165,166c114,115
< module_init(dscp_tg_init);
< module_exit(dscp_tg_exit);
---
> module_init(dscp_mt_init);
> module_exit(dscp_mt_exit);
diff -r xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/net/netfilter/xt_hl.c /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/net/netfilter/xt_hl.c
2,3c2,3
<  * IP tables module for matching the value of the TTL
<  * (C) 2000,2001 by Harald Welte <laforge@netfilter.org>
---
>  * TTL modification target for IP tables
>  * (C) 2000,2005 by Harald Welte <laforge@netfilter.org>
5,6c5,6
<  * Hop Limit matching module
<  * (C) 2001-2002 Maciej Soltysiak <solt@dns.toxicfilms.tv>
---
>  * Hop Limit modification target for ip6tables
>  * Maciej Soltysiak <solt@dns.toxicfilms.tv>
12,14c12
< 
< #include <linux/ip.h>
< #include <linux/ipv6.h>
---
> #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
16a15,17
> #include <linux/ip.h>
> #include <linux/ipv6.h>
> #include <net/checksum.h>
19,20c20,21
< #include <linux/netfilter_ipv4/ipt_ttl.h>
< #include <linux/netfilter_ipv6/ip6t_hl.h>
---
> #include <linux/netfilter_ipv4/ipt_TTL.h>
> #include <linux/netfilter_ipv6/ip6t_HL.h>
21a23
> MODULE_AUTHOR("Harald Welte <laforge@netfilter.org>");
23c25
< MODULE_DESCRIPTION("Xtables: Hoplimit/TTL field match");
---
> MODULE_DESCRIPTION("Xtables: Hoplimit/TTL Limit field modification target");
25,26d26
< MODULE_ALIAS("ipt_ttl");
< MODULE_ALIAS("ip6t_hl");
28c28,29
< static bool ttl_mt(const struct sk_buff *skb, struct xt_action_param *par)
---
> static unsigned int
> ttl_tg(struct sk_buff *skb, const struct xt_action_param *par)
30,31c31,38
< 	const struct ipt_ttl_info *info = par->matchinfo;
< 	const u8 ttl = ip_hdr(skb)->ttl;
---
> 	struct iphdr *iph;
> 	const struct ipt_TTL_info *info = par->targinfo;
> 	int new_ttl;
> 
> 	if (!skb_make_writable(skb, skb->len))
> 		return NF_DROP;
> 
> 	iph = ip_hdr(skb);
34,41c41,62
< 	case IPT_TTL_EQ:
< 		return ttl == info->ttl;
< 	case IPT_TTL_NE:
< 		return ttl != info->ttl;
< 	case IPT_TTL_LT:
< 		return ttl < info->ttl;
< 	case IPT_TTL_GT:
< 		return ttl > info->ttl;
---
> 	case IPT_TTL_SET:
> 		new_ttl = info->ttl;
> 		break;
> 	case IPT_TTL_INC:
> 		new_ttl = iph->ttl + info->ttl;
> 		if (new_ttl > 255)
> 			new_ttl = 255;
> 		break;
> 	case IPT_TTL_DEC:
> 		new_ttl = iph->ttl - info->ttl;
> 		if (new_ttl < 0)
> 			new_ttl = 0;
> 		break;
> 	default:
> 		new_ttl = iph->ttl;
> 		break;
> 	}
> 
> 	if (new_ttl != iph->ttl) {
> 		csum_replace2(&iph->check, htons(iph->ttl << 8),
> 					   htons(new_ttl << 8));
> 		iph->ttl = new_ttl;
44c65
< 	return false;
---
> 	return XT_CONTINUE;
47c68,69
< static bool hl_mt6(const struct sk_buff *skb, struct xt_action_param *par)
---
> static unsigned int
> hl_tg6(struct sk_buff *skb, const struct xt_action_param *par)
49,50c71,78
< 	const struct ip6t_hl_info *info = par->matchinfo;
< 	const struct ipv6hdr *ip6h = ipv6_hdr(skb);
---
> 	struct ipv6hdr *ip6h;
> 	const struct ip6t_HL_info *info = par->targinfo;
> 	int new_hl;
> 
> 	if (!skb_make_writable(skb, skb->len))
> 		return NF_DROP;
> 
> 	ip6h = ipv6_hdr(skb);
53,60c81,96
< 	case IP6T_HL_EQ:
< 		return ip6h->hop_limit == info->hop_limit;
< 	case IP6T_HL_NE:
< 		return ip6h->hop_limit != info->hop_limit;
< 	case IP6T_HL_LT:
< 		return ip6h->hop_limit < info->hop_limit;
< 	case IP6T_HL_GT:
< 		return ip6h->hop_limit > info->hop_limit;
---
> 	case IP6T_HL_SET:
> 		new_hl = info->hop_limit;
> 		break;
> 	case IP6T_HL_INC:
> 		new_hl = ip6h->hop_limit + info->hop_limit;
> 		if (new_hl > 255)
> 			new_hl = 255;
> 		break;
> 	case IP6T_HL_DEC:
> 		new_hl = ip6h->hop_limit - info->hop_limit;
> 		if (new_hl < 0)
> 			new_hl = 0;
> 		break;
> 	default:
> 		new_hl = ip6h->hop_limit;
> 		break;
63c99,130
< 	return false;
---
> 	ip6h->hop_limit = new_hl;
> 
> 	return XT_CONTINUE;
> }
> 
> static int ttl_tg_check(const struct xt_tgchk_param *par)
> {
> 	const struct ipt_TTL_info *info = par->targinfo;
> 
> 	if (info->mode > IPT_TTL_MAXMODE) {
> 		pr_info("TTL: invalid or unknown mode %u\n", info->mode);
> 		return -EINVAL;
> 	}
> 	if (info->mode != IPT_TTL_SET && info->ttl == 0)
> 		return -EINVAL;
> 	return 0;
> }
> 
> static int hl_tg6_check(const struct xt_tgchk_param *par)
> {
> 	const struct ip6t_HL_info *info = par->targinfo;
> 
> 	if (info->mode > IP6T_HL_MAXMODE) {
> 		pr_info("invalid or unknown mode %u\n", info->mode);
> 		return -EINVAL;
> 	}
> 	if (info->mode != IP6T_HL_SET && info->hop_limit == 0) {
> 		pr_info("increment/decrement does not "
> 			"make sense with value 0\n");
> 		return -EINVAL;
> 	}
> 	return 0;
66c133
< static struct xt_match hl_mt_reg[] __read_mostly = {
---
> static struct xt_target hl_tg_reg[] __read_mostly = {
68c135
< 		.name       = "ttl",
---
> 		.name       = "TTL",
71,72c138,141
< 		.match      = ttl_mt,
< 		.matchsize  = sizeof(struct ipt_ttl_info),
---
> 		.target     = ttl_tg,
> 		.targetsize = sizeof(struct ipt_TTL_info),
> 		.table      = "mangle",
> 		.checkentry = ttl_tg_check,
76c145
< 		.name       = "hl",
---
> 		.name       = "HL",
79,80c148,151
< 		.match      = hl_mt6,
< 		.matchsize  = sizeof(struct ip6t_hl_info),
---
> 		.target     = hl_tg6,
> 		.targetsize = sizeof(struct ip6t_HL_info),
> 		.table      = "mangle",
> 		.checkentry = hl_tg6_check,
85c156
< static int __init hl_mt_init(void)
---
> static int __init hl_tg_init(void)
87c158
< 	return xt_register_matches(hl_mt_reg, ARRAY_SIZE(hl_mt_reg));
---
> 	return xt_register_targets(hl_tg_reg, ARRAY_SIZE(hl_tg_reg));
90c161
< static void __exit hl_mt_exit(void)
---
> static void __exit hl_tg_exit(void)
92c163
< 	xt_unregister_matches(hl_mt_reg, ARRAY_SIZE(hl_mt_reg));
---
> 	xt_unregister_targets(hl_tg_reg, ARRAY_SIZE(hl_tg_reg));
95,96c166,169
< module_init(hl_mt_init);
< module_exit(hl_mt_exit);
---
> module_init(hl_tg_init);
> module_exit(hl_tg_exit);
> MODULE_ALIAS("ipt_TTL");
> MODULE_ALIAS("ip6t_HL");
diff -r xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/net/netfilter/xt_HL.c /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/net/netfilter/xt_HL.c
2,3c2,3
<  * TTL modification target for IP tables
<  * (C) 2000,2005 by Harald Welte <laforge@netfilter.org>
---
>  * IP tables module for matching the value of the TTL
>  * (C) 2000,2001 by Harald Welte <laforge@netfilter.org>
5,6c5,6
<  * Hop Limit modification target for ip6tables
<  * Maciej Soltysiak <solt@dns.toxicfilms.tv>
---
>  * Hop Limit matching module
>  * (C) 2001-2002 Maciej Soltysiak <solt@dns.toxicfilms.tv>
12,14c12
< #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
< #include <linux/module.h>
< #include <linux/skbuff.h>
---
> 
17c15,16
< #include <net/checksum.h>
---
> #include <linux/module.h>
> #include <linux/skbuff.h>
20,21c19,20
< #include <linux/netfilter_ipv4/ipt_TTL.h>
< #include <linux/netfilter_ipv6/ip6t_HL.h>
---
> #include <linux/netfilter_ipv4/ipt_ttl.h>
> #include <linux/netfilter_ipv6/ip6t_hl.h>
23d21
< MODULE_AUTHOR("Harald Welte <laforge@netfilter.org>");
25c23
< MODULE_DESCRIPTION("Xtables: Hoplimit/TTL Limit field modification target");
---
> MODULE_DESCRIPTION("Xtables: Hoplimit/TTL field match");
26a25,26
> MODULE_ALIAS("ipt_ttl");
> MODULE_ALIAS("ip6t_hl");
28,29c28
< static unsigned int
< ttl_tg(struct sk_buff *skb, const struct xt_action_param *par)
---
> static bool ttl_mt(const struct sk_buff *skb, struct xt_action_param *par)
31,38c30,31
< 	struct iphdr *iph;
< 	const struct ipt_TTL_info *info = par->targinfo;
< 	int new_ttl;
< 
< 	if (!skb_make_writable(skb, skb->len))
< 		return NF_DROP;
< 
< 	iph = ip_hdr(skb);
---
> 	const struct ipt_ttl_info *info = par->matchinfo;
> 	const u8 ttl = ip_hdr(skb)->ttl;
41,62c34,41
< 	case IPT_TTL_SET:
< 		new_ttl = info->ttl;
< 		break;
< 	case IPT_TTL_INC:
< 		new_ttl = iph->ttl + info->ttl;
< 		if (new_ttl > 255)
< 			new_ttl = 255;
< 		break;
< 	case IPT_TTL_DEC:
< 		new_ttl = iph->ttl - info->ttl;
< 		if (new_ttl < 0)
< 			new_ttl = 0;
< 		break;
< 	default:
< 		new_ttl = iph->ttl;
< 		break;
< 	}
< 
< 	if (new_ttl != iph->ttl) {
< 		csum_replace2(&iph->check, htons(iph->ttl << 8),
< 					   htons(new_ttl << 8));
< 		iph->ttl = new_ttl;
---
> 	case IPT_TTL_EQ:
> 		return ttl == info->ttl;
> 	case IPT_TTL_NE:
> 		return ttl != info->ttl;
> 	case IPT_TTL_LT:
> 		return ttl < info->ttl;
> 	case IPT_TTL_GT:
> 		return ttl > info->ttl;
65c44
< 	return XT_CONTINUE;
---
> 	return false;
68,69c47
< static unsigned int
< hl_tg6(struct sk_buff *skb, const struct xt_action_param *par)
---
> static bool hl_mt6(const struct sk_buff *skb, struct xt_action_param *par)
71,78c49,50
< 	struct ipv6hdr *ip6h;
< 	const struct ip6t_HL_info *info = par->targinfo;
< 	int new_hl;
< 
< 	if (!skb_make_writable(skb, skb->len))
< 		return NF_DROP;
< 
< 	ip6h = ipv6_hdr(skb);
---
> 	const struct ip6t_hl_info *info = par->matchinfo;
> 	const struct ipv6hdr *ip6h = ipv6_hdr(skb);
81,96c53,60
< 	case IP6T_HL_SET:
< 		new_hl = info->hop_limit;
< 		break;
< 	case IP6T_HL_INC:
< 		new_hl = ip6h->hop_limit + info->hop_limit;
< 		if (new_hl > 255)
< 			new_hl = 255;
< 		break;
< 	case IP6T_HL_DEC:
< 		new_hl = ip6h->hop_limit - info->hop_limit;
< 		if (new_hl < 0)
< 			new_hl = 0;
< 		break;
< 	default:
< 		new_hl = ip6h->hop_limit;
< 		break;
---
> 	case IP6T_HL_EQ:
> 		return ip6h->hop_limit == info->hop_limit;
> 	case IP6T_HL_NE:
> 		return ip6h->hop_limit != info->hop_limit;
> 	case IP6T_HL_LT:
> 		return ip6h->hop_limit < info->hop_limit;
> 	case IP6T_HL_GT:
> 		return ip6h->hop_limit > info->hop_limit;
99,130c63
< 	ip6h->hop_limit = new_hl;
< 
< 	return XT_CONTINUE;
< }
< 
< static int ttl_tg_check(const struct xt_tgchk_param *par)
< {
< 	const struct ipt_TTL_info *info = par->targinfo;
< 
< 	if (info->mode > IPT_TTL_MAXMODE) {
< 		pr_info("TTL: invalid or unknown mode %u\n", info->mode);
< 		return -EINVAL;
< 	}
< 	if (info->mode != IPT_TTL_SET && info->ttl == 0)
< 		return -EINVAL;
< 	return 0;
< }
< 
< static int hl_tg6_check(const struct xt_tgchk_param *par)
< {
< 	const struct ip6t_HL_info *info = par->targinfo;
< 
< 	if (info->mode > IP6T_HL_MAXMODE) {
< 		pr_info("invalid or unknown mode %u\n", info->mode);
< 		return -EINVAL;
< 	}
< 	if (info->mode != IP6T_HL_SET && info->hop_limit == 0) {
< 		pr_info("increment/decrement does not "
< 			"make sense with value 0\n");
< 		return -EINVAL;
< 	}
< 	return 0;
---
> 	return false;
133c66
< static struct xt_target hl_tg_reg[] __read_mostly = {
---
> static struct xt_match hl_mt_reg[] __read_mostly = {
135c68
< 		.name       = "TTL",
---
> 		.name       = "ttl",
138,141c71,72
< 		.target     = ttl_tg,
< 		.targetsize = sizeof(struct ipt_TTL_info),
< 		.table      = "mangle",
< 		.checkentry = ttl_tg_check,
---
> 		.match      = ttl_mt,
> 		.matchsize  = sizeof(struct ipt_ttl_info),
145c76
< 		.name       = "HL",
---
> 		.name       = "hl",
148,151c79,80
< 		.target     = hl_tg6,
< 		.targetsize = sizeof(struct ip6t_HL_info),
< 		.table      = "mangle",
< 		.checkentry = hl_tg6_check,
---
> 		.match      = hl_mt6,
> 		.matchsize  = sizeof(struct ip6t_hl_info),
156c85
< static int __init hl_tg_init(void)
---
> static int __init hl_mt_init(void)
158c87
< 	return xt_register_targets(hl_tg_reg, ARRAY_SIZE(hl_tg_reg));
---
> 	return xt_register_matches(hl_mt_reg, ARRAY_SIZE(hl_mt_reg));
161c90
< static void __exit hl_tg_exit(void)
---
> static void __exit hl_mt_exit(void)
163c92
< 	xt_unregister_targets(hl_tg_reg, ARRAY_SIZE(hl_tg_reg));
---
> 	xt_unregister_matches(hl_mt_reg, ARRAY_SIZE(hl_mt_reg));
166,169c95,96
< module_init(hl_tg_init);
< module_exit(hl_tg_exit);
< MODULE_ALIAS("ipt_TTL");
< MODULE_ALIAS("ip6t_HL");
---
> module_init(hl_mt_init);
> module_exit(hl_mt_exit);
diff -r xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/net/netfilter/xt_rateest.c /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/net/netfilter/xt_rateest.c
10a11,16
> #include <linux/jhash.h>
> #include <linux/rtnetlink.h>
> #include <linux/random.h>
> #include <linux/slab.h>
> #include <net/gen_stats.h>
> #include <net/netlink.h>
13c19
< #include <linux/netfilter/xt_rateest.h>
---
> #include <linux/netfilter/xt_RATEEST.h>
15a22
> static DEFINE_MUTEX(xt_rateest_mutex);
17,18c24,29
< static bool
< xt_rateest_mt(const struct sk_buff *skb, struct xt_action_param *par)
---
> #define RATEEST_HSIZE	16
> static struct hlist_head rateest_hash[RATEEST_HSIZE] __read_mostly;
> static unsigned int jhash_rnd __read_mostly;
> static bool rnd_inited __read_mostly;
> 
> static unsigned int xt_rateest_hash(const char *name)
20,34c31,41
< 	const struct xt_rateest_match_info *info = par->matchinfo;
< 	struct gnet_stats_rate_est64 *r;
< 	u_int32_t bps1, bps2, pps1, pps2;
< 	bool ret = true;
< 
< 	spin_lock_bh(&info->est1->lock);
< 	r = &info->est1->rstats;
< 	if (info->flags & XT_RATEEST_MATCH_DELTA) {
< 		bps1 = info->bps1 >= r->bps ? info->bps1 - r->bps : 0;
< 		pps1 = info->pps1 >= r->pps ? info->pps1 - r->pps : 0;
< 	} else {
< 		bps1 = r->bps;
< 		pps1 = r->pps;
< 	}
< 	spin_unlock_bh(&info->est1->lock);
---
> 	return jhash(name, FIELD_SIZEOF(struct xt_rateest, name), jhash_rnd) &
> 	       (RATEEST_HSIZE - 1);
> }
> 
> static void xt_rateest_hash_insert(struct xt_rateest *est)
> {
> 	unsigned int h;
> 
> 	h = xt_rateest_hash(est->name);
> 	hlist_add_head(&est->list, &rateest_hash[h]);
> }
36,47c43,54
< 	if (info->flags & XT_RATEEST_MATCH_ABS) {
< 		bps2 = info->bps2;
< 		pps2 = info->pps2;
< 	} else {
< 		spin_lock_bh(&info->est2->lock);
< 		r = &info->est2->rstats;
< 		if (info->flags & XT_RATEEST_MATCH_DELTA) {
< 			bps2 = info->bps2 >= r->bps ? info->bps2 - r->bps : 0;
< 			pps2 = info->pps2 >= r->pps ? info->pps2 - r->pps : 0;
< 		} else {
< 			bps2 = r->bps;
< 			pps2 = r->pps;
---
> struct xt_rateest *xt_rateest_lookup(const char *name)
> {
> 	struct xt_rateest *est;
> 	unsigned int h;
> 
> 	h = xt_rateest_hash(name);
> 	mutex_lock(&xt_rateest_mutex);
> 	hlist_for_each_entry(est, &rateest_hash[h], list) {
> 		if (strcmp(est->name, name) == 0) {
> 			est->refcnt++;
> 			mutex_unlock(&xt_rateest_mutex);
> 			return est;
49d55
< 		spin_unlock_bh(&info->est2->lock);
50a57,60
> 	mutex_unlock(&xt_rateest_mutex);
> 	return NULL;
> }
> EXPORT_SYMBOL_GPL(xt_rateest_lookup);
52,70c62,72
< 	switch (info->mode) {
< 	case XT_RATEEST_MATCH_LT:
< 		if (info->flags & XT_RATEEST_MATCH_BPS)
< 			ret &= bps1 < bps2;
< 		if (info->flags & XT_RATEEST_MATCH_PPS)
< 			ret &= pps1 < pps2;
< 		break;
< 	case XT_RATEEST_MATCH_GT:
< 		if (info->flags & XT_RATEEST_MATCH_BPS)
< 			ret &= bps1 > bps2;
< 		if (info->flags & XT_RATEEST_MATCH_PPS)
< 			ret &= pps1 > pps2;
< 		break;
< 	case XT_RATEEST_MATCH_EQ:
< 		if (info->flags & XT_RATEEST_MATCH_BPS)
< 			ret &= bps1 == bps2;
< 		if (info->flags & XT_RATEEST_MATCH_PPS)
< 			ret &= pps1 == pps2;
< 		break;
---
> void xt_rateest_put(struct xt_rateest *est)
> {
> 	mutex_lock(&xt_rateest_mutex);
> 	if (--est->refcnt == 0) {
> 		hlist_del(&est->list);
> 		gen_kill_estimator(&est->bstats, &est->rstats);
> 		/*
> 		 * gen_estimator est_timer() might access est->lock or bstats,
> 		 * wait a RCU grace period before freeing 'est'
> 		 */
> 		kfree_rcu(est, rcu);
72,74c74
< 
< 	ret ^= info->flags & XT_RATEEST_MATCH_INVERT ? true : false;
< 	return ret;
---
> 	mutex_unlock(&xt_rateest_mutex);
75a76
> EXPORT_SYMBOL_GPL(xt_rateest_put);
77c78,79
< static int xt_rateest_mt_checkentry(const struct xt_mtchk_param *par)
---
> static unsigned int
> xt_rateest_tg(struct sk_buff *skb, const struct xt_action_param *par)
79,81c81,82
< 	struct xt_rateest_match_info *info = par->matchinfo;
< 	struct xt_rateest *est1, *est2;
< 	int ret = -EINVAL;
---
> 	const struct xt_rateest_target_info *info = par->targinfo;
> 	struct gnet_stats_basic_packed *stats = &info->est->bstats;
83,85c84,87
< 	if (hweight32(info->flags & (XT_RATEEST_MATCH_ABS |
< 				     XT_RATEEST_MATCH_REL)) != 1)
< 		goto err1;
---
> 	spin_lock_bh(&info->est->lock);
> 	stats->bytes += skb->len;
> 	stats->packets++;
> 	spin_unlock_bh(&info->est->lock);
87,88c89,90
< 	if (!(info->flags & (XT_RATEEST_MATCH_BPS | XT_RATEEST_MATCH_PPS)))
< 		goto err1;
---
> 	return XT_CONTINUE;
> }
90,96c92,120
< 	switch (info->mode) {
< 	case XT_RATEEST_MATCH_EQ:
< 	case XT_RATEEST_MATCH_LT:
< 	case XT_RATEEST_MATCH_GT:
< 		break;
< 	default:
< 		goto err1;
---
> static int xt_rateest_tg_checkentry(const struct xt_tgchk_param *par)
> {
> 	struct xt_rateest_target_info *info = par->targinfo;
> 	struct xt_rateest *est;
> 	struct {
> 		struct nlattr		opt;
> 		struct gnet_estimator	est;
> 	} cfg;
> 	int ret;
> 
> 	if (unlikely(!rnd_inited)) {
> 		get_random_bytes(&jhash_rnd, sizeof(jhash_rnd));
> 		rnd_inited = true;
> 	}
> 
> 	est = xt_rateest_lookup(info->name);
> 	if (est) {
> 		/*
> 		 * If estimator parameters are specified, they must match the
> 		 * existing estimator.
> 		 */
> 		if ((!info->interval && !info->ewma_log) ||
> 		    (info->interval != est->params.interval ||
> 		     info->ewma_log != est->params.ewma_log)) {
> 			xt_rateest_put(est);
> 			return -EINVAL;
> 		}
> 		info->est = est;
> 		return 0;
99,101c123,125
< 	ret  = -ENOENT;
< 	est1 = xt_rateest_lookup(info->name1);
< 	if (!est1)
---
> 	ret = -ENOMEM;
> 	est = kzalloc(sizeof(*est), GFP_KERNEL);
> 	if (!est)
104,109c128,142
< 	est2 = NULL;
< 	if (info->flags & XT_RATEEST_MATCH_REL) {
< 		est2 = xt_rateest_lookup(info->name2);
< 		if (!est2)
< 			goto err2;
< 	}
---
> 	strlcpy(est->name, info->name, sizeof(est->name));
> 	spin_lock_init(&est->lock);
> 	est->refcnt		= 1;
> 	est->params.interval	= info->interval;
> 	est->params.ewma_log	= info->ewma_log;
> 
> 	cfg.opt.nla_len		= nla_attr_size(sizeof(cfg.est));
> 	cfg.opt.nla_type	= TCA_STATS_RATE_EST;
> 	cfg.est.interval	= info->interval;
> 	cfg.est.ewma_log	= info->ewma_log;
> 
> 	ret = gen_new_estimator(&est->bstats, NULL, &est->rstats,
> 				&est->lock, &cfg.opt);
> 	if (ret < 0)
> 		goto err2;
111,112c144,145
< 	info->est1 = est1;
< 	info->est2 = est2;
---
> 	info->est = est;
> 	xt_rateest_hash_insert(est);
116c149
< 	xt_rateest_put(est1);
---
> 	kfree(est);
121c154
< static void xt_rateest_mt_destroy(const struct xt_mtdtor_param *par)
---
> static void xt_rateest_tg_destroy(const struct xt_tgdtor_param *par)
123c156
< 	struct xt_rateest_match_info *info = par->matchinfo;
---
> 	struct xt_rateest_target_info *info = par->targinfo;
125,127c158
< 	xt_rateest_put(info->est1);
< 	if (info->est2)
< 		xt_rateest_put(info->est2);
---
> 	xt_rateest_put(info->est);
130,131c161,162
< static struct xt_match xt_rateest_mt_reg __read_mostly = {
< 	.name       = "rateest",
---
> static struct xt_target xt_rateest_tg_reg __read_mostly = {
> 	.name       = "RATEEST",
134,137c165,168
< 	.match      = xt_rateest_mt,
< 	.checkentry = xt_rateest_mt_checkentry,
< 	.destroy    = xt_rateest_mt_destroy,
< 	.matchsize  = sizeof(struct xt_rateest_match_info),
---
> 	.target     = xt_rateest_tg,
> 	.checkentry = xt_rateest_tg_checkentry,
> 	.destroy    = xt_rateest_tg_destroy,
> 	.targetsize = sizeof(struct xt_rateest_target_info),
141c172
< static int __init xt_rateest_mt_init(void)
---
> static int __init xt_rateest_tg_init(void)
143c174,179
< 	return xt_register_match(&xt_rateest_mt_reg);
---
> 	unsigned int i;
> 
> 	for (i = 0; i < ARRAY_SIZE(rateest_hash); i++)
> 		INIT_HLIST_HEAD(&rateest_hash[i]);
> 
> 	return xt_register_target(&xt_rateest_tg_reg);
146c182
< static void __exit xt_rateest_mt_fini(void)
---
> static void __exit xt_rateest_tg_fini(void)
148c184
< 	xt_unregister_match(&xt_rateest_mt_reg);
---
> 	xt_unregister_target(&xt_rateest_tg_reg);
150a187
> 
153,157c190,194
< MODULE_DESCRIPTION("xtables rate estimator match");
< MODULE_ALIAS("ipt_rateest");
< MODULE_ALIAS("ip6t_rateest");
< module_init(xt_rateest_mt_init);
< module_exit(xt_rateest_mt_fini);
---
> MODULE_DESCRIPTION("Xtables: packet rate estimator");
> MODULE_ALIAS("ipt_RATEEST");
> MODULE_ALIAS("ip6t_RATEEST");
> module_init(xt_rateest_tg_init);
> module_exit(xt_rateest_tg_fini);
diff -r xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/net/netfilter/xt_RATEEST.c /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/net/netfilter/xt_RATEEST.c
11,16d10
< #include <linux/jhash.h>
< #include <linux/rtnetlink.h>
< #include <linux/random.h>
< #include <linux/slab.h>
< #include <net/gen_stats.h>
< #include <net/netlink.h>
19c13
< #include <linux/netfilter/xt_RATEEST.h>
---
> #include <linux/netfilter/xt_rateest.h>
22d15
< static DEFINE_MUTEX(xt_rateest_mutex);
24,35c17,18
< #define RATEEST_HSIZE	16
< static struct hlist_head rateest_hash[RATEEST_HSIZE] __read_mostly;
< static unsigned int jhash_rnd __read_mostly;
< static bool rnd_inited __read_mostly;
< 
< static unsigned int xt_rateest_hash(const char *name)
< {
< 	return jhash(name, FIELD_SIZEOF(struct xt_rateest, name), jhash_rnd) &
< 	       (RATEEST_HSIZE - 1);
< }
< 
< static void xt_rateest_hash_insert(struct xt_rateest *est)
---
> static bool
> xt_rateest_mt(const struct sk_buff *skb, struct xt_action_param *par)
37,46c20,34
< 	unsigned int h;
< 
< 	h = xt_rateest_hash(est->name);
< 	hlist_add_head(&est->list, &rateest_hash[h]);
< }
< 
< struct xt_rateest *xt_rateest_lookup(const char *name)
< {
< 	struct xt_rateest *est;
< 	unsigned int h;
---
> 	const struct xt_rateest_match_info *info = par->matchinfo;
> 	struct gnet_stats_rate_est64 *r;
> 	u_int32_t bps1, bps2, pps1, pps2;
> 	bool ret = true;
> 
> 	spin_lock_bh(&info->est1->lock);
> 	r = &info->est1->rstats;
> 	if (info->flags & XT_RATEEST_MATCH_DELTA) {
> 		bps1 = info->bps1 >= r->bps ? info->bps1 - r->bps : 0;
> 		pps1 = info->pps1 >= r->pps ? info->pps1 - r->pps : 0;
> 	} else {
> 		bps1 = r->bps;
> 		pps1 = r->pps;
> 	}
> 	spin_unlock_bh(&info->est1->lock);
48,54c36,47
< 	h = xt_rateest_hash(name);
< 	mutex_lock(&xt_rateest_mutex);
< 	hlist_for_each_entry(est, &rateest_hash[h], list) {
< 		if (strcmp(est->name, name) == 0) {
< 			est->refcnt++;
< 			mutex_unlock(&xt_rateest_mutex);
< 			return est;
---
> 	if (info->flags & XT_RATEEST_MATCH_ABS) {
> 		bps2 = info->bps2;
> 		pps2 = info->pps2;
> 	} else {
> 		spin_lock_bh(&info->est2->lock);
> 		r = &info->est2->rstats;
> 		if (info->flags & XT_RATEEST_MATCH_DELTA) {
> 			bps2 = info->bps2 >= r->bps ? info->bps2 - r->bps : 0;
> 			pps2 = info->pps2 >= r->pps ? info->pps2 - r->pps : 0;
> 		} else {
> 			bps2 = r->bps;
> 			pps2 = r->pps;
55a49
> 		spin_unlock_bh(&info->est2->lock);
57,60d50
< 	mutex_unlock(&xt_rateest_mutex);
< 	return NULL;
< }
< EXPORT_SYMBOL_GPL(xt_rateest_lookup);
62,72c52,70
< void xt_rateest_put(struct xt_rateest *est)
< {
< 	mutex_lock(&xt_rateest_mutex);
< 	if (--est->refcnt == 0) {
< 		hlist_del(&est->list);
< 		gen_kill_estimator(&est->bstats, &est->rstats);
< 		/*
< 		 * gen_estimator est_timer() might access est->lock or bstats,
< 		 * wait a RCU grace period before freeing 'est'
< 		 */
< 		kfree_rcu(est, rcu);
---
> 	switch (info->mode) {
> 	case XT_RATEEST_MATCH_LT:
> 		if (info->flags & XT_RATEEST_MATCH_BPS)
> 			ret &= bps1 < bps2;
> 		if (info->flags & XT_RATEEST_MATCH_PPS)
> 			ret &= pps1 < pps2;
> 		break;
> 	case XT_RATEEST_MATCH_GT:
> 		if (info->flags & XT_RATEEST_MATCH_BPS)
> 			ret &= bps1 > bps2;
> 		if (info->flags & XT_RATEEST_MATCH_PPS)
> 			ret &= pps1 > pps2;
> 		break;
> 	case XT_RATEEST_MATCH_EQ:
> 		if (info->flags & XT_RATEEST_MATCH_BPS)
> 			ret &= bps1 == bps2;
> 		if (info->flags & XT_RATEEST_MATCH_PPS)
> 			ret &= pps1 == pps2;
> 		break;
74c72,74
< 	mutex_unlock(&xt_rateest_mutex);
---
> 
> 	ret ^= info->flags & XT_RATEEST_MATCH_INVERT ? true : false;
> 	return ret;
76d75
< EXPORT_SYMBOL_GPL(xt_rateest_put);
78,79c77
< static unsigned int
< xt_rateest_tg(struct sk_buff *skb, const struct xt_action_param *par)
---
> static int xt_rateest_mt_checkentry(const struct xt_mtchk_param *par)
81,82c79,81
< 	const struct xt_rateest_target_info *info = par->targinfo;
< 	struct gnet_stats_basic_packed *stats = &info->est->bstats;
---
> 	struct xt_rateest_match_info *info = par->matchinfo;
> 	struct xt_rateest *est1, *est2;
> 	int ret = -EINVAL;
84,90c83,85
< 	spin_lock_bh(&info->est->lock);
< 	stats->bytes += skb->len;
< 	stats->packets++;
< 	spin_unlock_bh(&info->est->lock);
< 
< 	return XT_CONTINUE;
< }
---
> 	if (hweight32(info->flags & (XT_RATEEST_MATCH_ABS |
> 				     XT_RATEEST_MATCH_REL)) != 1)
> 		goto err1;
92,105c87,88
< static int xt_rateest_tg_checkentry(const struct xt_tgchk_param *par)
< {
< 	struct xt_rateest_target_info *info = par->targinfo;
< 	struct xt_rateest *est;
< 	struct {
< 		struct nlattr		opt;
< 		struct gnet_estimator	est;
< 	} cfg;
< 	int ret;
< 
< 	if (unlikely(!rnd_inited)) {
< 		get_random_bytes(&jhash_rnd, sizeof(jhash_rnd));
< 		rnd_inited = true;
< 	}
---
> 	if (!(info->flags & (XT_RATEEST_MATCH_BPS | XT_RATEEST_MATCH_PPS)))
> 		goto err1;
107,120c90,96
< 	est = xt_rateest_lookup(info->name);
< 	if (est) {
< 		/*
< 		 * If estimator parameters are specified, they must match the
< 		 * existing estimator.
< 		 */
< 		if ((!info->interval && !info->ewma_log) ||
< 		    (info->interval != est->params.interval ||
< 		     info->ewma_log != est->params.ewma_log)) {
< 			xt_rateest_put(est);
< 			return -EINVAL;
< 		}
< 		info->est = est;
< 		return 0;
---
> 	switch (info->mode) {
> 	case XT_RATEEST_MATCH_EQ:
> 	case XT_RATEEST_MATCH_LT:
> 	case XT_RATEEST_MATCH_GT:
> 		break;
> 	default:
> 		goto err1;
123,125c99,101
< 	ret = -ENOMEM;
< 	est = kzalloc(sizeof(*est), GFP_KERNEL);
< 	if (!est)
---
> 	ret  = -ENOENT;
> 	est1 = xt_rateest_lookup(info->name1);
> 	if (!est1)
128,142c104,109
< 	strlcpy(est->name, info->name, sizeof(est->name));
< 	spin_lock_init(&est->lock);
< 	est->refcnt		= 1;
< 	est->params.interval	= info->interval;
< 	est->params.ewma_log	= info->ewma_log;
< 
< 	cfg.opt.nla_len		= nla_attr_size(sizeof(cfg.est));
< 	cfg.opt.nla_type	= TCA_STATS_RATE_EST;
< 	cfg.est.interval	= info->interval;
< 	cfg.est.ewma_log	= info->ewma_log;
< 
< 	ret = gen_new_estimator(&est->bstats, NULL, &est->rstats,
< 				&est->lock, &cfg.opt);
< 	if (ret < 0)
< 		goto err2;
---
> 	est2 = NULL;
> 	if (info->flags & XT_RATEEST_MATCH_REL) {
> 		est2 = xt_rateest_lookup(info->name2);
> 		if (!est2)
> 			goto err2;
> 	}
144,145c111,112
< 	info->est = est;
< 	xt_rateest_hash_insert(est);
---
> 	info->est1 = est1;
> 	info->est2 = est2;
149c116
< 	kfree(est);
---
> 	xt_rateest_put(est1);
154c121
< static void xt_rateest_tg_destroy(const struct xt_tgdtor_param *par)
---
> static void xt_rateest_mt_destroy(const struct xt_mtdtor_param *par)
156c123
< 	struct xt_rateest_target_info *info = par->targinfo;
---
> 	struct xt_rateest_match_info *info = par->matchinfo;
158c125,127
< 	xt_rateest_put(info->est);
---
> 	xt_rateest_put(info->est1);
> 	if (info->est2)
> 		xt_rateest_put(info->est2);
161,162c130,131
< static struct xt_target xt_rateest_tg_reg __read_mostly = {
< 	.name       = "RATEEST",
---
> static struct xt_match xt_rateest_mt_reg __read_mostly = {
> 	.name       = "rateest",
165,168c134,137
< 	.target     = xt_rateest_tg,
< 	.checkentry = xt_rateest_tg_checkentry,
< 	.destroy    = xt_rateest_tg_destroy,
< 	.targetsize = sizeof(struct xt_rateest_target_info),
---
> 	.match      = xt_rateest_mt,
> 	.checkentry = xt_rateest_mt_checkentry,
> 	.destroy    = xt_rateest_mt_destroy,
> 	.matchsize  = sizeof(struct xt_rateest_match_info),
172c141
< static int __init xt_rateest_tg_init(void)
---
> static int __init xt_rateest_mt_init(void)
174,179c143
< 	unsigned int i;
< 
< 	for (i = 0; i < ARRAY_SIZE(rateest_hash); i++)
< 		INIT_HLIST_HEAD(&rateest_hash[i]);
< 
< 	return xt_register_target(&xt_rateest_tg_reg);
---
> 	return xt_register_match(&xt_rateest_mt_reg);
182c146
< static void __exit xt_rateest_tg_fini(void)
---
> static void __exit xt_rateest_mt_fini(void)
184c148
< 	xt_unregister_target(&xt_rateest_tg_reg);
---
> 	xt_unregister_match(&xt_rateest_mt_reg);
187d150
< 
190,194c153,157
< MODULE_DESCRIPTION("Xtables: packet rate estimator");
< MODULE_ALIAS("ipt_RATEEST");
< MODULE_ALIAS("ip6t_RATEEST");
< module_init(xt_rateest_tg_init);
< module_exit(xt_rateest_tg_fini);
---
> MODULE_DESCRIPTION("xtables rate estimator match");
> MODULE_ALIAS("ipt_rateest");
> MODULE_ALIAS("ip6t_rateest");
> module_init(xt_rateest_mt_init);
> module_exit(xt_rateest_mt_fini);
Only in /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/net/netfilter: XT_TCP~3.C
diff -r xval_skylark_4.06.35-beta_rc/val_extended_src/4.06.35-beta_rc/linux/net/netfilter/xt_tcpmss.c /projects/hcm/skylark/users/mnguyen/o_xval_skylark/linux_frw/linux/net/netfilter/xt_tcpmss.c
1,4c1,5
< /* Kernel module to match TCP MSS values. */
< 
< /* Copyright (C) 2000 Marc Boucher <marc@mbsi.ca>
<  * Portions (C) 2005 by Harald Welte <laforge@netfilter.org>
---
> /*
>  * This is a module which is used for setting the MSS option in TCP packets.
>  *
>  * Copyright (C) 2000 Marc Boucher <marc@mbsi.ca>
>  * Copyright (C) 2007 Patrick McHardy <kaber@trash.net>
10c11
< 
---
> #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
12a14,21
> #include <linux/ip.h>
> #include <linux/gfp.h>
> #include <linux/ipv6.h>
> #include <linux/tcp.h>
> #include <net/dst.h>
> #include <net/flow.h>
> #include <net/ipv6.h>
> #include <net/route.h>
15,17d23
< #include <linux/netfilter/xt_tcpmss.h>
< #include <linux/netfilter/x_tables.h>
< 
19a26,28
> #include <linux/netfilter/x_tables.h>
> #include <linux/netfilter/xt_tcpudp.h>
> #include <linux/netfilter/xt_TCPMSS.h>
23,60c32,60
< MODULE_DESCRIPTION("Xtables: TCP MSS match");
< MODULE_ALIAS("ipt_tcpmss");
< MODULE_ALIAS("ip6t_tcpmss");
< 
< static bool
< tcpmss_mt(const struct sk_buff *skb, struct xt_action_param *par)
< {
< 	const struct xt_tcpmss_match_info *info = par->matchinfo;
< 	const struct tcphdr *th;
< 	struct tcphdr _tcph;
< 	/* tcp.doff is only 4 bits, ie. max 15 * 4 bytes */
< 	const u_int8_t *op;
< 	u8 _opt[15 * 4 - sizeof(_tcph)];
< 	unsigned int i, optlen;
< 
< 	/* If we don't have the whole header, drop packet. */
< 	th = skb_header_pointer(skb, par->thoff, sizeof(_tcph), &_tcph);
< 	if (th == NULL)
< 		goto dropit;
< 
< 	/* Malformed. */
< 	if (th->doff*4 < sizeof(*th))
< 		goto dropit;
< 
< 	optlen = th->doff*4 - sizeof(*th);
< 	if (!optlen)
< 		goto out;
< 
< 	/* Truncated options. */
< 	op = skb_header_pointer(skb, par->thoff + sizeof(*th), optlen, _opt);
< 	if (op == NULL)
< 		goto dropit;
< 
< 	for (i = 0; i < optlen; ) {
< 		if (op[i] == TCPOPT_MSS
< 		    && (optlen - i) >= TCPOLEN_MSS
< 		    && op[i+1] == TCPOLEN_MSS) {
< 			u_int16_t mssval;
---
> MODULE_DESCRIPTION("Xtables: TCP Maximum Segment Size (MSS) adjustment");
> MODULE_ALIAS("ipt_TCPMSS");
> MODULE_ALIAS("ip6t_TCPMSS");
> 
> static inline unsigned int
> optlen(const u_int8_t *opt, unsigned int offset)
> {
> 	/* Beware zero-length options: make finite progress */
> 	if (opt[offset] <= TCPOPT_NOP || opt[offset+1] == 0)
> 		return 1;
> 	else
> 		return opt[offset+1];
> }
> 
> static u_int32_t tcpmss_reverse_mtu(struct net *net,
> 				    const struct sk_buff *skb,
> 				    unsigned int family)
> {
> 	struct flowi fl;
> 	const struct nf_afinfo *ai;
> 	struct rtable *rt = NULL;
> 	u_int32_t mtu     = ~0U;
> 
> 	if (family == PF_INET) {
> 		struct flowi4 *fl4 = &fl.u.ip4;
> 		memset(fl4, 0, sizeof(*fl4));
> 		fl4->daddr = ip_hdr(skb)->saddr;
> 	} else {
> 		struct flowi6 *fl6 = &fl.u.ip6;
62c62,76
< 			mssval = (op[i+2] << 8) | op[i+3];
---
> 		memset(fl6, 0, sizeof(*fl6));
> 		fl6->daddr = ipv6_hdr(skb)->saddr;
> 	}
> 	rcu_read_lock();
> 	ai = nf_get_afinfo(family);
> 	if (ai != NULL)
> 		ai->route(net, (struct dst_entry **)&rt, &fl, false);
> 	rcu_read_unlock();
> 
> 	if (rt != NULL) {
> 		mtu = dst_mtu(&rt->dst);
> 		dst_release(&rt->dst);
> 	}
> 	return mtu;
> }
64,65c78,148
< 			return (mssval >= info->mss_min &&
< 				mssval <= info->mss_max) ^ info->invert;
---
> static int
> tcpmss_mangle_packet(struct sk_buff *skb,
> 		     const struct xt_action_param *par,
> 		     unsigned int family,
> 		     unsigned int tcphoff,
> 		     unsigned int minlen)
> {
> 	const struct xt_tcpmss_info *info = par->targinfo;
> 	struct tcphdr *tcph;
> 	int len, tcp_hdrlen;
> 	unsigned int i;
> 	__be16 oldval;
> 	u16 newmss;
> 	u8 *opt;
> 
> 	/* This is a fragment, no TCP header is available */
> 	if (par->fragoff != 0)
> 		return 0;
> 
> 	if (!skb_make_writable(skb, skb->len))
> 		return -1;
> 
> 	len = skb->len - tcphoff;
> 	if (len < (int)sizeof(struct tcphdr))
> 		return -1;
> 
> 	tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
> 	tcp_hdrlen = tcph->doff * 4;
> 
> 	if (len < tcp_hdrlen)
> 		return -1;
> 
> 	if (info->mss == XT_TCPMSS_CLAMP_PMTU) {
> 		struct net *net = par->net;
> 		unsigned int in_mtu = tcpmss_reverse_mtu(net, skb, family);
> 
> 		if (dst_mtu(skb_dst(skb)) <= minlen) {
> 			net_err_ratelimited("unknown or invalid path-MTU (%u)\n",
> 					    dst_mtu(skb_dst(skb)));
> 			return -1;
> 		}
> 		if (in_mtu <= minlen) {
> 			net_err_ratelimited("unknown or invalid path-MTU (%u)\n",
> 					    in_mtu);
> 			return -1;
> 		}
> 		newmss = min(dst_mtu(skb_dst(skb)), in_mtu) - minlen;
> 	} else
> 		newmss = info->mss;
> 
> 	opt = (u_int8_t *)tcph;
> 	for (i = sizeof(struct tcphdr); i <= tcp_hdrlen - TCPOLEN_MSS; i += optlen(opt, i)) {
> 		if (opt[i] == TCPOPT_MSS && opt[i+1] == TCPOLEN_MSS) {
> 			u_int16_t oldmss;
> 
> 			oldmss = (opt[i+2] << 8) | opt[i+3];
> 
> 			/* Never increase MSS, even when setting it, as
> 			 * doing so results in problems for hosts that rely
> 			 * on MSS being set correctly.
> 			 */
> 			if (oldmss <= newmss)
> 				return 0;
> 
> 			opt[i+2] = (newmss & 0xff00) >> 8;
> 			opt[i+3] = newmss & 0x00ff;
> 
> 			inet_proto_csum_replace2(&tcph->check, skb,
> 						 htons(oldmss), htons(newmss),
> 						 false);
> 			return 0;
67,70d149
< 		if (op[i] < 2)
< 			i++;
< 		else
< 			i += op[i+1] ? : 1;
72,73d150
< out:
< 	return info->invert;
75,76c152,267
< dropit:
< 	par->hotdrop = true;
---
> 	/* There is data after the header so the option can't be added
> 	 * without moving it, and doing so may make the SYN packet
> 	 * itself too large. Accept the packet unmodified instead.
> 	 */
> 	if (len > tcp_hdrlen)
> 		return 0;
> 
> 	/*
> 	 * MSS Option not found ?! add it..
> 	 */
> 	if (skb_tailroom(skb) < TCPOLEN_MSS) {
> 		if (pskb_expand_head(skb, 0,
> 				     TCPOLEN_MSS - skb_tailroom(skb),
> 				     GFP_ATOMIC))
> 			return -1;
> 		tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
> 	}
> 
> 	skb_put(skb, TCPOLEN_MSS);
> 
> 	/*
> 	 * IPv4: RFC 1122 states "If an MSS option is not received at
> 	 * connection setup, TCP MUST assume a default send MSS of 536".
> 	 * IPv6: RFC 2460 states IPv6 has a minimum MTU of 1280 and a minimum
> 	 * length IPv6 header of 60, ergo the default MSS value is 1220
> 	 * Since no MSS was provided, we must use the default values
> 	 */
> 	if (par->family == NFPROTO_IPV4)
> 		newmss = min(newmss, (u16)536);
> 	else
> 		newmss = min(newmss, (u16)1220);
> 
> 	opt = (u_int8_t *)tcph + sizeof(struct tcphdr);
> 	memmove(opt + TCPOLEN_MSS, opt, len - sizeof(struct tcphdr));
> 
> 	inet_proto_csum_replace2(&tcph->check, skb,
> 				 htons(len), htons(len + TCPOLEN_MSS), true);
> 	opt[0] = TCPOPT_MSS;
> 	opt[1] = TCPOLEN_MSS;
> 	opt[2] = (newmss & 0xff00) >> 8;
> 	opt[3] = newmss & 0x00ff;
> 
> 	inet_proto_csum_replace4(&tcph->check, skb, 0, *((__be32 *)opt), false);
> 
> 	oldval = ((__be16 *)tcph)[6];
> 	tcph->doff += TCPOLEN_MSS/4;
> 	inet_proto_csum_replace2(&tcph->check, skb,
> 				 oldval, ((__be16 *)tcph)[6], false);
> 	return TCPOLEN_MSS;
> }
> 
> static unsigned int
> tcpmss_tg4(struct sk_buff *skb, const struct xt_action_param *par)
> {
> 	struct iphdr *iph = ip_hdr(skb);
> 	__be16 newlen;
> 	int ret;
> 
> 	ret = tcpmss_mangle_packet(skb, par,
> 				   PF_INET,
> 				   iph->ihl * 4,
> 				   sizeof(*iph) + sizeof(struct tcphdr));
> 	if (ret < 0)
> 		return NF_DROP;
> 	if (ret > 0) {
> 		iph = ip_hdr(skb);
> 		newlen = htons(ntohs(iph->tot_len) + ret);
> 		csum_replace2(&iph->check, iph->tot_len, newlen);
> 		iph->tot_len = newlen;
> 	}
> 	return XT_CONTINUE;
> }
> 
> #if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)
> static unsigned int
> tcpmss_tg6(struct sk_buff *skb, const struct xt_action_param *par)
> {
> 	struct ipv6hdr *ipv6h = ipv6_hdr(skb);
> 	u8 nexthdr;
> 	__be16 frag_off, oldlen, newlen;
> 	int tcphoff;
> 	int ret;
> 
> 	nexthdr = ipv6h->nexthdr;
> 	tcphoff = ipv6_skip_exthdr(skb, sizeof(*ipv6h), &nexthdr, &frag_off);
> 	if (tcphoff < 0)
> 		return NF_DROP;
> 	ret = tcpmss_mangle_packet(skb, par,
> 				   PF_INET6,
> 				   tcphoff,
> 				   sizeof(*ipv6h) + sizeof(struct tcphdr));
> 	if (ret < 0)
> 		return NF_DROP;
> 	if (ret > 0) {
> 		ipv6h = ipv6_hdr(skb);
> 		oldlen = ipv6h->payload_len;
> 		newlen = htons(ntohs(oldlen) + ret);
> 		if (skb->ip_summed == CHECKSUM_COMPLETE)
> 			skb->csum = csum_add(csum_sub(skb->csum, oldlen),
> 					     newlen);
> 		ipv6h->payload_len = newlen;
> 	}
> 	return XT_CONTINUE;
> }
> #endif
> 
> /* Must specify -p tcp --syn */
> static inline bool find_syn_match(const struct xt_entry_match *m)
> {
> 	const struct xt_tcp *tcpinfo = (const struct xt_tcp *)m->data;
> 
> 	if (strcmp(m->u.kernel.match->name, "tcp") == 0 &&
> 	    tcpinfo->flg_cmp & TCPHDR_SYN &&
> 	    !(tcpinfo->invflags & XT_TCP_INV_FLAGS))
> 		return true;
> 
80c271,321
< static struct xt_match tcpmss_mt_reg[] __read_mostly = {
---
> static int tcpmss_tg4_check(const struct xt_tgchk_param *par)
> {
> 	const struct xt_tcpmss_info *info = par->targinfo;
> 	const struct ipt_entry *e = par->entryinfo;
> 	const struct xt_entry_match *ematch;
> 
> 	if (info->mss == XT_TCPMSS_CLAMP_PMTU &&
> 	    (par->hook_mask & ~((1 << NF_INET_FORWARD) |
> 			   (1 << NF_INET_LOCAL_OUT) |
> 			   (1 << NF_INET_POST_ROUTING))) != 0) {
> 		pr_info("path-MTU clamping only supported in "
> 			"FORWARD, OUTPUT and POSTROUTING hooks\n");
> 		return -EINVAL;
> 	}
> 	if (par->nft_compat)
> 		return 0;
> 
> 	xt_ematch_foreach(ematch, e)
> 		if (find_syn_match(ematch))
> 			return 0;
> 	pr_info("Only works on TCP SYN packets\n");
> 	return -EINVAL;
> }
> 
> #if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)
> static int tcpmss_tg6_check(const struct xt_tgchk_param *par)
> {
> 	const struct xt_tcpmss_info *info = par->targinfo;
> 	const struct ip6t_entry *e = par->entryinfo;
> 	const struct xt_entry_match *ematch;
> 
> 	if (info->mss == XT_TCPMSS_CLAMP_PMTU &&
> 	    (par->hook_mask & ~((1 << NF_INET_FORWARD) |
> 			   (1 << NF_INET_LOCAL_OUT) |
> 			   (1 << NF_INET_POST_ROUTING))) != 0) {
> 		pr_info("path-MTU clamping only supported in "
> 			"FORWARD, OUTPUT and POSTROUTING hooks\n");
> 		return -EINVAL;
> 	}
> 	if (par->nft_compat)
> 		return 0;
> 
> 	xt_ematch_foreach(ematch, e)
> 		if (find_syn_match(ematch))
> 			return 0;
> 	pr_info("Only works on TCP SYN packets\n");
> 	return -EINVAL;
> }
> #endif
> 
> static struct xt_target tcpmss_tg_reg[] __read_mostly = {
82d322
< 		.name		= "tcpmss",
84,85c324,327
< 		.match		= tcpmss_mt,
< 		.matchsize	= sizeof(struct xt_tcpmss_match_info),
---
> 		.name		= "TCPMSS",
> 		.checkentry	= tcpmss_tg4_check,
> 		.target		= tcpmss_tg4,
> 		.targetsize	= sizeof(struct xt_tcpmss_info),
88a331
> #if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)
90d332
< 		.name		= "tcpmss",
92,93c334,337
< 		.match		= tcpmss_mt,
< 		.matchsize	= sizeof(struct xt_tcpmss_match_info),
---
> 		.name		= "TCPMSS",
> 		.checkentry	= tcpmss_tg6_check,
> 		.target		= tcpmss_tg6,
> 		.targetsize	= sizeof(struct xt_tcpmss_info),
96a341
> #endif
99c344
< static int __init tcpmss_mt_init(void)
---
> static int __init tcpmss_tg_init(void)
101c346
< 	return xt_register_matches(tcpmss_mt_reg, ARRAY_SIZE(tcpmss_mt_reg));
---
> 	return xt_register_targets(tcpmss_tg_reg, ARRAY_SIZE(tcpmss_tg_reg));
104c349
< static void __exit tcpmss_mt_exit(void)
---
> static void __exit tcpmss_tg_exit(void)
106c351
< 	xt_unregister_matches(tcpmss_mt_reg, ARRAY_SIZE(tcpmss_mt_reg));
---
> 	xt_unregister_targets(tcpmss_tg_reg, ARRAY_SIZE(tcpmss_tg_reg));
109,110c354,355
< module_init(tcpmss_mt_init);
< module_exit(tcpmss_mt_exit);
---
> module_init(tcpmss_tg_init);
> module_exit(tcpmss_tg_exit);
